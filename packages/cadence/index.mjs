// Auto-generated. Do not edit by hand.
export const files = {};
files["transactions/vault/user/submit-and-mint_dynamic.cdc"] = "import \"NonFungibleToken\"\nimport \"FungibleToken\"\nimport \"Fractional\"\nimport \"VaultShareToken\"\n\n// One-shot dual-authorizer: user deposits NFT to custody, admin creates vault metadata,\n// user ensures share receiver setup for the concrete per‑vault FT, admin optionally sets max supply,\n// and admin mints initial shares to the user.\n//\n// The VaultShareToken import is expected to be aliased at send-time to the concrete series contract\n// for the given vaultId/symbol (e.g., import MySeries as VaultShareToken from 0xADMIN).\ntransaction(\n  vaultId: String,\n  collectionStoragePath: String,\n  collectionPublicPath: String,\n  tokenId: UInt64,\n  shareSymbol: String,\n  policy: String,\n  maxSupply: UFix64?,\n  initialMint: UFix64,\n  ftAddress: Address,\n  ftContractName: String,\n  vaultStoragePathIdentifier: String,\n  receiverPublicPathIdentifier: String,\n  balancePublicPathIdentifier: String\n) {\n  prepare(\n    user: auth(\n      BorrowValue,\n      SaveValue,\n      Storage,\n      Capabilities,\n      IssueStorageCapabilityController,\n      PublishCapability,\n      UnpublishCapability\n    ) &Account,\n    admin: auth(\n      BorrowValue,\n      IssueStorageCapabilityController,\n      SaveValue,\n      PublishCapability,\n      UnpublishCapability,\n      Storage\n    ) &Account\n  ) {\n    // 1) Determine if user still holds the NFT in public collection\n\n    // If the user's public collection no longer contains the token, assume it's already deposited and skip\n    let pubPath: PublicPath = PublicPath(identifier: collectionPublicPath)!\n    var shouldDeposit: Bool = true\n   let pubCap: Capability<&{NonFungibleToken.CollectionPublic}> =\n  user.capabilities.get<&{NonFungibleToken.CollectionPublic}>(pubPath)\n\n    if pubCap.check() {\n      let pubRef = pubCap.borrow() ?? panic(\"public collection capability not borrowable\")\n      let ids: [UInt64] = pubRef.getIDs()\n\n      var found: Bool = false\n      var i: Int = 0\n      while i < ids.length {\n        if ids[i] == tokenId { found = true; break }\n        i = i + 1\n      }\n      if !found { shouldDeposit = false }\n    }\n\n    // (Withdraw and deposit handled after vault metadata creation into LockBox)\n\n    // 2) Admin: create vault metadata (LockBox policy)\n    let adminRef: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    var didCreateVault: Bool = false\n    if Fractional.getVault(vaultId: vaultId) == nil {\n      adminRef.createVaultFromNFT(\n        vaultId: vaultId,\n        collectionStoragePath: collectionStoragePath,\n        collectionPublicPath: collectionPublicPath,\n        tokenId: tokenId,\n        shareSymbol: shareSymbol,\n        policy: \"lockbox\",\n        creator: user.address\n      )\n      didCreateVault = true\n    }\n\n    // 3) User: if needed, withdraw NFT and deposit into LockBox, emit event\n    if shouldDeposit {\n      let colStoragePath: StoragePath = StoragePath(identifier: collectionStoragePath)!\n      let providerRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider} = user.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: colStoragePath)\n        ?? panic(\"missing provider at storage path\")\n      let nft: @{NonFungibleToken.NFT} <- providerRef.withdraw(withdrawID: tokenId)\n      if user.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox) == nil {\n        user.storage.save(<- Fractional.createLockBox(), to: /storage/FractionalLockBox)\n      }\n      let _: Capability? = user.capabilities.unpublish(Fractional.LockBoxPublicPath)\n      user.capabilities.publish(\n        user.capabilities.storage.issue<&{Fractional.LockBoxPublic}>(/storage/FractionalLockBox),\n        at: Fractional.LockBoxPublicPath\n      )\n      let lb: &Fractional.LockBox = user.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox)!\n      lb.deposit(vaultId: vaultId, nft: <- nft)\n      adminRef.emitUnderlyingDeposited(\n        vaultId: vaultId,\n        collectionStoragePath: collectionStoragePath,\n        collectionPublicPath: collectionPublicPath,\n        tokenId: tokenId,\n        nftType: \"NonFungibleToken.NFT\"\n      )\n    }\n\n    // Register per‑vault FT to this vault now that it exists\n    var didRegisterFT: Bool = false\n    if Fractional.getVaultFT(vaultId: vaultId) == nil {\n      adminRef.setVaultFT(\n        vaultId: vaultId,\n        ftAddress: ftAddress,\n        ftContractName: ftContractName,\n        vaultStoragePathIdentifier: vaultStoragePathIdentifier,\n        receiverPublicPathIdentifier: receiverPublicPathIdentifier,\n        balancePublicPathIdentifier: balancePublicPathIdentifier\n      )\n      didRegisterFT = true\n    }\n  \n    // 4) User: ensure share vault & receiver/balance caps for the per‑vault FT\n    let shareStoragePath: StoragePath = VaultShareToken.getVaultStoragePath()\n    let shareReceiverPath: PublicPath = VaultShareToken.getReceiverPublicPath()\n    let shareBalancePath: PublicPath = VaultShareToken.getBalancePublicPath()\n\n    if user.storage.borrow<&VaultShareToken.Vault>(from: shareStoragePath) == nil {\n      let any: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let v: @VaultShareToken.Vault <- any as! @VaultShareToken.Vault\n      user.storage.save(<- v, to: shareStoragePath)\n    }\n\n    // Publish receiver if missing\n    let recvCapExisting = user.capabilities.get<&{FungibleToken.Receiver}>(shareReceiverPath)\n    if recvCapExisting == nil || !(recvCapExisting!.check()) {\n      let _ru: Capability? = user.capabilities.unpublish(shareReceiverPath)\n      user.capabilities.publish(\n        user.capabilities.storage.issue<&{FungibleToken.Receiver}>(shareStoragePath),\n        at: shareReceiverPath\n      )\n    }\n    // Publish balance if missing\n    let balCapExisting = user.capabilities.get<&VaultShareToken.Vault>(shareBalancePath)\n    if balCapExisting == nil || !(balCapExisting!.check()) {\n      let _bu: Capability? = user.capabilities.unpublish(shareBalancePath)\n      user.capabilities.publish(\n        user.capabilities.storage.issue<&VaultShareToken.Vault>(shareStoragePath),\n        at: shareBalancePath\n      )\n    }\n\n    // 5) Admin: optional max supply, and mint initial shares to user\n    if maxSupply != nil {\n      if let v = Fractional.getVault(vaultId: vaultId) {\n        if v.maxSupply == nil { adminRef.setMaxSupply(vaultId: vaultId, maxSupply: maxSupply!) }\n      }\n    }\n\n    // Mint only on first registration to avoid duplicate mint from retries\n    if initialMint > 0.0 && didRegisterFT {\n      let adminToken = VaultShareToken.borrowAdmin() ?? panic(\"missing VaultShareToken.Admin\")\n      let recvCap = user.capabilities.get<&{FungibleToken.Receiver}>(shareReceiverPath)\n      if !recvCap.check() { panic(\"user receiver not linked\") }\n      let receiver = recvCap.borrow() ?? panic(\"user receiver missing\")\n      adminToken.mint(to: receiver, amount: initialMint)\n\n      // Optional convenience: emit Fractional-level SharesMinted for indexers\n      adminRef.emitSharesMinted(symbol: shareSymbol, accounts: [user.address], amounts: [initialMint])\n    }\n  }\n}\n\n\n";
files["transactions/vault/user/submit-from-collection.cdc"] = "import \"NonFungibleToken\"\nimport \"Fractional\"\n\n// User submits an owned NFT for fractionalization with platform admin co-signing.\n// Authorizer order: user first, admin second.\ntransaction(\n  vaultId: String,\n  collectionStoragePath: String,\n  collectionPublicPath: String,\n  tokenId: UInt64,\n  shareSymbol: String,\n  policy: String\n) {\n  prepare(\n    user: auth(\n      BorrowValue,\n      SaveValue,\n      Storage,\n      Capabilities,\n      IssueStorageCapabilityController,\n      PublishCapability,\n      UnpublishCapability\n    ) &Account,\n    admin: auth(Storage) &Account\n  ) {\n    let storagePath: StoragePath = StoragePath(identifier: collectionStoragePath)!\n\n    // Withdraw user's NFT\n    let providerRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider} = user.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: storagePath)\n      ?? panic(\"missing provider at storage path\")\n    let nft: @{NonFungibleToken.NFT} <- providerRef.withdraw(withdrawID: tokenId)\n\n    // Create vault metadata via admin (when using lockbox we must create first to pass deposit validation)\n    let adminRef: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n\n    // Always use LockBox custody (default)\n    adminRef.createVaultFromNFT(\n      vaultId: vaultId,\n      collectionStoragePath: collectionStoragePath,\n      collectionPublicPath: collectionPublicPath,\n      tokenId: tokenId,\n      shareSymbol: shareSymbol,\n      policy: \"lockbox\",\n      creator: user.address\n    )\n\n    // Ensure LockBox exists and publish public capability\n    if user.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox) == nil {\n      user.storage.save(<- Fractional.createLockBox(), to: /storage/FractionalLockBox)\n    }\n    let _: Capability? = user.capabilities.unpublish(Fractional.LockBoxPublicPath)\n    user.capabilities.publish(\n      user.capabilities.storage.issue<&{Fractional.LockBoxPublic}>(/storage/FractionalLockBox),\n      at: Fractional.LockBoxPublicPath\n    )\n    let lb: &Fractional.LockBox = user.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox)!\n    lb.deposit(vaultId: vaultId, nft: <-nft)\n    adminRef.emitUnderlyingDeposited(\n      vaultId: vaultId,\n      collectionStoragePath: collectionStoragePath,\n      collectionPublicPath: collectionPublicPath,\n      tokenId: tokenId,\n      nftType: \"NonFungibleToken.NFT\"\n    )\n  }\n}\n\n\n\n\n";
files["transactions/vault/admin/activate-fee-params.cdc"] = "import \"Fractional\"\n\ntransaction(vaultId: String, currentHeight: UInt64) {\n  prepare(admin: auth(Storage) &Account) {\n    let ref: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    ref.activateFeeParams(vaultId: vaultId, currentHeight: currentHeight)\n  }\n}\n\n\n";
files["transactions/vault/admin/create-from-nft.cdc"] = "import \"NonFungibleToken\"\nimport \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  collectionStoragePath: String,\n  collectionPublicPath: String,\n  tokenId: UInt64,\n  shareSymbol: String,\n  policy: String\n) {\n    prepare(signer: auth(BorrowValue, SaveValue, Storage, Capabilities) &Account) {\n        let storagePath: StoragePath = StoragePath(identifier: collectionStoragePath)!\n        let providerRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider} = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: storagePath)\n            ?? panic(\"missing provider at storage path\")\n        let nft: @{NonFungibleToken.NFT} <- providerRef.withdraw(withdrawID: tokenId)\n        // Create vault metadata first when using lockbox to satisfy deposit validation\n        let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n            ?? panic(\"missing admin\")\n        // Always use LockBox custody (default)\n        admin.createVaultFromNFT(\n          vaultId: vaultId,\n          collectionStoragePath: collectionStoragePath,\n          collectionPublicPath: collectionPublicPath,\n          tokenId: tokenId,\n          shareSymbol: shareSymbol,\n          policy: \"lockbox\",\n          creator: signer.address\n        )\n\n        if signer.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox) == nil {\n            signer.storage.save(<- Fractional.createLockBox(), to: /storage/FractionalLockBox)\n        }\n        let _: Capability? = signer.capabilities.unpublish(Fractional.LockBoxPublicPath)\n        signer.capabilities.publish(\n            signer.capabilities.storage.issue<&{Fractional.LockBoxPublic}>(/storage/FractionalLockBox),\n            at: Fractional.LockBoxPublicPath\n        )\n        let lb: &Fractional.LockBox = signer.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox)!\n        lb.deposit(vaultId: vaultId, nft: <-nft)\n\n        admin.emitUnderlyingDeposited(\n          vaultId: vaultId,\n          collectionStoragePath: collectionStoragePath,\n          collectionPublicPath: collectionPublicPath,\n          tokenId: tokenId,\n          nftType: \"NonFungibleToken.NFT\"\n        )\n    }\n}\n\n\n";
files["transactions/vault/admin/create.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  collection: String,\n  tokenId: UInt64,\n  shareSymbol: String,\n  policy: String\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.createVault(\n      vaultId: vaultId,\n      collection: collection,\n      tokenId: tokenId,\n      shareSymbol: shareSymbol,\n      policy: policy,\n      creator: signer.address\n    )\n  }\n}\n\n\n\n\n";
files["transactions/vault/admin/init-series-vault.cdc"] = "import \"VaultShareToken\"\n\ntransaction() {\n  prepare(admin: auth(Storage, BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {\n    let storagePath: StoragePath = VaultShareToken.getVaultStoragePath()\n    if admin.storage.borrow<&VaultShareToken.Vault>(from: storagePath) == nil {\n      let any <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let v: @VaultShareToken.Vault <- any as! @VaultShareToken.Vault\n      admin.storage.save(<-v, to: storagePath)\n    }\n  }\n}\n\n\n";
files["transactions/vault/admin/redeem-and-withdraw.cdc"] = "import \"NonFungibleToken\"\nimport \"Fractional\"\n\n// NOTE: This transaction assumes all outstanding shares have been burned\n// prior to execution. It sets the vault state to redeemed and withdraws\n// the underlying NFT from the custodian's LockBox, depositing it back\n// to the custodian's original collection path recorded in the vault.\n// Authorizer order: admin first, then custodian.\ntransaction(\n  vaultId: String\n) {\n  prepare(\n    admin: auth(Storage) &Account,\n    custodian: auth(BorrowValue, Storage, Capabilities) &Account\n  ) {\n    let adminRef: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n\n    // Borrow LockBox from the custodian's storage\n    let lb: &Fractional.LockBox = custodian.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox)\n      ?? panic(\"missing LockBox\")\n\n    // Redeem and pull NFT out of LockBox\n    // NOTE: Caller must ensure total supply has been burned; pass 0.0 to assert\n    let nft: @{NonFungibleToken.NFT} <- adminRef.redeemAndWithdraw(lockbox: lb, vaultId: vaultId, declaredTotalSupply: 0.0)\n\n    // Read target collection path from vault metadata\n    let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n    let storagePath: StoragePath = StoragePath(identifier: v.collectionStoragePath)!\n\n    // Deposit NFT back to the custodian's collection\n    let receiver: &{NonFungibleToken.Receiver} = custodian.storage.borrow<&{NonFungibleToken.Receiver}>(from: storagePath)\n      ?? panic(\"recipient collection missing\")\n    receiver.deposit(token: <- nft)\n  }\n}\n\n\n";
files["transactions/vault/admin/redeem.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.redeem(vaultId: vaultId)\n  }\n}\n\n\n";
files["transactions/vault/admin/schedule-fee-params.cdc"] = "import \"Fractional\"\n\ntransaction(vaultId: String, feeBps: UInt64, vaultSplitBps: UInt64, protocolSplitBps: UInt64, effectiveAt: UInt64) {\n  prepare(admin: auth(Storage) &Account) {\n    let ref: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    ref.scheduleFeeParams(vaultId: vaultId, feeBps: feeBps, vaultSplitBps: vaultSplitBps, protocolSplitBps: protocolSplitBps, effectiveAt: effectiveAt)\n  }\n}\n\n\n";
files["transactions/vault/admin/set-max-supply.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  maxSupply: UFix64\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.setMaxSupply(vaultId: vaultId, maxSupply: maxSupply)\n  }\n}\n\n\n";
files["transactions/vault/admin/set_ft.cdc"] = "import \"Fractional\"\n\n/// Registers the concrete FT contract for a vault's share token.\n/// Must be called by the platform admin that holds `Fractional.Admin` in storage.\n///\n/// Args:\n/// - vaultId: ID of the vault/series\n/// - ftAddress: address where the FT contract is deployed\n/// - ftContractName: contract name (at ftAddress) for the FT\n/// - vaultStoragePathIdentifier: identifier for StoragePath (e.g., \"vault_SYMBOL\")\n/// - receiverPublicPathIdentifier: identifier for PublicPath receiver (e.g., \"receiver_SYMBOL\")\n/// - balancePublicPathIdentifier: identifier for PublicPath balance (e.g., \"balance_SYMBOL\")\ntransaction(\n  vaultId: String,\n  ftAddress: Address,\n  ftContractName: String,\n  vaultStoragePathIdentifier: String,\n  receiverPublicPathIdentifier: String,\n  balancePublicPathIdentifier: String\n) {\n  prepare(admin: auth(Storage) &Account) {\n    let adminRef: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing Fractional.Admin\")\n\n    adminRef.setVaultFT(\n      vaultId: vaultId,\n      ftAddress: ftAddress,\n      ftContractName: ftContractName,\n      vaultStoragePathIdentifier: vaultStoragePathIdentifier,\n      receiverPublicPathIdentifier: receiverPublicPathIdentifier,\n      balancePublicPathIdentifier: balancePublicPathIdentifier\n    )\n  }\n}\n\n\n";
files["transactions/treasury/admin/ensure-caps.cdc"] = "import \"FlowToken\"\n\ntransaction(vaultId: String) {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability, Storage) &Account) {\n    if admin.storage.borrow<&FlowToken.Vault>(from: /storage/PlatformTreasury_FLOW) == nil {\n      let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      admin.storage.save(<-v, to: /storage/PlatformTreasury_FLOW)\n    }\n    let _ = admin.capabilities.unpublish(/public/PlatformTreasury_FLOW)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&FlowToken.Vault>(/storage/PlatformTreasury_FLOW),\n      at: /public/PlatformTreasury_FLOW\n    )\n\n    let vtIdent = \"VaultTreasury_FLOW_\".concat(vaultId)\n    let vtStorage = StoragePath(identifier: vtIdent)!\n    let vtPublic = PublicPath(identifier: vtIdent)!\n    if admin.storage.borrow<&FlowToken.Vault>(from: vtStorage) == nil {\n      let v2: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      admin.storage.save(<-v2, to: vtStorage)\n    }\n    let __ = admin.capabilities.unpublish(vtPublic)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&FlowToken.Vault>(vtStorage),\n      at: vtPublic\n    )\n  }\n}\n\n\n";
files["transactions/treasury/admin/ensure_treasuries_dynamic.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\n\n/// Ensures admin treasuries exist and are published for a given token ident and optional vault.\n/// - tokenIdent: e.g., \"FLOW\" or the per‑vault FT contract name aliased as VaultShareToken\n/// - vaultId: optional; when provided, ensures per‑vault treasury as well\ntransaction(tokenIdent: String, vaultId: String?) {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability, Storage) &Account) {\n    // Platform treasury: /storage|/public/PlatformTreasury_<TOKEN>\n    let platStorage: StoragePath = StoragePath(identifier: \"PlatformTreasury_\".concat(tokenIdent))!\n    let platPublic: PublicPath = PublicPath(identifier: \"PlatformTreasury_\".concat(tokenIdent))!\n\n    if tokenIdent == \"FLOW\" {\n      if admin.storage.borrow<&FlowToken.Vault>(from: platStorage) == nil {\n        let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n        admin.storage.save(<-v, to: platStorage)\n      }\n      let _ = admin.capabilities.unpublish(platPublic)\n      admin.capabilities.publish(admin.capabilities.storage.issue<&FlowToken.Vault>(platStorage), at: platPublic)\n    } else {\n      if admin.storage.borrow<&{FungibleToken.Vault}>(from: platStorage) == nil {\n        let vAny: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>()) as @{FungibleToken.Vault}\n        admin.storage.save(<-vAny, to: platStorage)\n      }\n      let _ = admin.capabilities.unpublish(platPublic)\n      admin.capabilities.publish(admin.capabilities.storage.issue<&{FungibleToken.Vault}>(platStorage), at: platPublic)\n    }\n\n    // Optional per‑vault treasury: /storage|/public/VaultTreasury_<TOKEN>_<vaultId>\n    if vaultId != nil {\n      let vtIdent = \"VaultTreasury_\".concat(tokenIdent).concat(\"_\").concat(vaultId!)\n      let vtStorage: StoragePath = StoragePath(identifier: vtIdent)!\n      let vtPublic: PublicPath = PublicPath(identifier: vtIdent)!\n\n      if tokenIdent == \"FLOW\" {\n        if admin.storage.borrow<&FlowToken.Vault>(from: vtStorage) == nil {\n          let v2: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n          admin.storage.save(<-v2, to: vtStorage)\n        }\n        let __ = admin.capabilities.unpublish(vtPublic)\n        admin.capabilities.publish(admin.capabilities.storage.issue<&FlowToken.Vault>(vtStorage), at: vtPublic)\n      } else {\n        if admin.storage.borrow<&{FungibleToken.Vault}>(from: vtStorage) == nil {\n          let v2Any: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>()) as @{FungibleToken.Vault}\n          admin.storage.save(<-v2Any, to: vtStorage)\n        }\n        let __ = admin.capabilities.unpublish(vtPublic)\n        admin.capabilities.publish(admin.capabilities.storage.issue<&{FungibleToken.Vault}>(vtStorage), at: vtPublic)\n      }\n    }\n  }\n}\n\n\n";
files["transactions/shares/user/setup.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Idempotent holder setup for VaultShareToken\n// - Creates empty Vault at contract-defined storage path if missing\n// - Publishes receiver and metadata caps at contract-defined public paths\ntransaction() {\n    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n        let storagePath: StoragePath = VaultShareToken.getVaultStoragePath()\n        let receiverPath: PublicPath = VaultShareToken.getReceiverPublicPath()\n        let metadataPath: PublicPath = VaultShareToken.getBalancePublicPath()\n\n        if signer.storage.borrow<&VaultShareToken.Vault>(from: storagePath) == nil {\n            let vault <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n            signer.storage.save(<-vault, to: storagePath)\n        }\n\n        // Receiver: &{FungibleToken.Receiver}\n        signer.capabilities.unpublish(receiverPath)\n        signer.capabilities.publish(\n            signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(storagePath),\n            at: receiverPath\n        )\n\n        // Metadata/balance: &VaultShareToken.Vault (resolver + balance)\n        signer.capabilities.unpublish(metadataPath)\n        signer.capabilities.publish(\n            signer.capabilities.storage.issue<&VaultShareToken.Vault>(storagePath),\n            at: metadataPath\n        )\n    }\n}\n\n\n";
files["transactions/shares/user/setup_dynamic.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Setup per‑vault FT vault and public caps\ntransaction() {\n  prepare(acct: auth(Storage, BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {\n    let storagePath: StoragePath = VaultShareToken.getVaultStoragePath()\n    let receiverPath: PublicPath = VaultShareToken.getReceiverPublicPath()\n    let balancePath: PublicPath = VaultShareToken.getBalancePublicPath()\n\n    if acct.storage.borrow<&VaultShareToken.Vault>(from: storagePath) == nil {\n      let any: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let v: @VaultShareToken.Vault <- any as! @VaultShareToken.Vault\n      acct.storage.save(<-v, to: storagePath)\n    }\n\n    let _r: Capability? = acct.capabilities.unpublish(receiverPath)\n    acct.capabilities.publish(\n      acct.capabilities.storage.issue<&{FungibleToken.Receiver}>(storagePath),\n      at: receiverPath\n    )\n\n    let _b: Capability? = acct.capabilities.unpublish(balancePath)\n    acct.capabilities.publish(\n      acct.capabilities.storage.issue<&VaultShareToken.Vault>(storagePath),\n      at: balancePath\n    )\n  }\n}\n\n\n";
files["transactions/shares/admin/ensure_admin_caps_dynamic.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Ensure admin escrow vault exists and publish receiver/balance caps using per‑vault FT\ntransaction(storageIdent: String, receiverIdent: String, balanceIdent: String) {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    let storagePath: StoragePath = StoragePath(identifier: storageIdent)!\n    let receiverPath: PublicPath = PublicPath(identifier: receiverIdent)!\n    let balancePath: PublicPath = PublicPath(identifier: balanceIdent)!\n\n    if admin.storage.borrow<&VaultShareToken.Vault>(from: storagePath) == nil {\n      let empty: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let escrow: @VaultShareToken.Vault <- empty as! @VaultShareToken.Vault\n      admin.storage.save(<-escrow, to: storagePath)\n    }\n\n    let _r: Capability? = admin.capabilities.unpublish(receiverPath)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&{FungibleToken.Receiver}>(storagePath),\n      at: receiverPath\n    )\n\n    let _b: Capability? = admin.capabilities.unpublish(balancePath)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&VaultShareToken.Vault>(storagePath),\n      at: balancePath\n    )\n  }\n}\n\n\n";
files["transactions/shares/admin/mint.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Mint VaultShareToken to a recipient using the contract Admin\n// Requires that the VaultShareToken contract's Admin resource exists in contract storage\n// and that the recipient has set up their VaultShareToken vault and receiver capability.\ntransaction(recipient: Address, amount: UFix64) {\n    prepare(signer: auth(Storage) &Account) {\n        let adminRef = VaultShareToken.borrowAdmin() ?? panic(\"missing VaultShareToken.Admin\")\n        let recv: Capability<&{FungibleToken.Receiver}> = getAccount(recipient)\n            .capabilities.get<&{FungibleToken.Receiver}>(VaultShareToken.getReceiverPublicPath())\n        adminRef.mint(to: recv.borrow() ?? panic(\"recipient receiver missing\"), amount: amount)\n    }\n}\n";
files["transactions/shares/admin/mint_dynamic.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Mint per‑vault FT to a recipient using the contract Admin\ntransaction(recipient: Address, amount: UFix64) {\n  prepare(signer: auth(Storage) &Account) {\n    let adminRef = VaultShareToken.borrowAdmin() ?? panic(\"missing Admin\")\n    let recv: Capability<&{FungibleToken.Receiver}> = getAccount(recipient)\n      .capabilities.get<&{FungibleToken.Receiver}>(VaultShareToken.getReceiverPublicPath())\n    adminRef.mint(to: recv.borrow() ?? panic(\"recipient receiver missing\"), amount: amount)\n  }\n}\n\n\n";
files["transactions/shares/admin/mint_to_treasury_dynamic.cdc"] = "import \"FungibleToken\"\nimport \"Fractional\"\nimport \"VaultShareToken\"\n\n/// Mint shares to vault treasury instead of a recipient\ntransaction(vaultId: String, amount: UFix64) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability, Storage) &Account) {\n    // Get vault FT metadata\n    let ftMeta: {String: String}? = Fractional.getVaultFT(vaultId: vaultId)\n    if ftMeta == nil { panic(\"vault FT not registered\") }\n    \n    let ftContractName: String = ftMeta![\"name\"]!\n    \n    // Vault treasury path: VaultTreasury_<CONTRACT_NAME>_<vaultId>\n    let vaultTreasuryIdent: String = \"VaultTreasury_\".concat(ftContractName).concat(\"_\").concat(vaultId)\n    let vaultTreasuryPublic: PublicPath = PublicPath(identifier: vaultTreasuryIdent)!\n    \n    // Get Admin from vault FT contract\n    let adminRef = VaultShareToken.borrowAdmin() ?? panic(\"missing VaultShareToken.Admin\")\n    \n    // Get vault treasury receiver capability\n    let treasuryRecv: Capability<&{FungibleToken.Vault}>? = signer.capabilities.get<&{FungibleToken.Vault}>(vaultTreasuryPublic)\n    if treasuryRecv == nil {\n      panic(\"vault treasury not published - ensure treasury is set up first\")\n    }\n    \n    // Mint to vault treasury\n    adminRef.mint(to: treasuryRecv!.borrow() ?? panic(\"treasury receiver missing\"), amount: amount)\n  }\n}\n\n";
files["transactions/shares/admin/set-transfer-mode.cdc"] = "import \"Fractional\"\n\ntransaction(\n  symbol: String,\n  mode: String\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.setTransferMode(symbol: symbol, mode: mode)\n  }\n}\n\n\n";
files["transactions/shares/admin/transfer.cdc"] = "import \"Fractional\"\n\ntransaction(\n  symbol: String,\n  from: Address,\n  to: Address,\n  amount: UFix64\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.transfer(symbol: symbol, from: from, to: to, amount: amount)\n  }\n}\n\n\n\n\n";
files["transactions/shares/admin/transfer_dynamic.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Admin-only transfer of shares from admin escrow to a recipient\n// This transaction is aliased at runtime so that VaultShareToken resolves\n// to the concrete per-vault FT contract.\ntransaction(\n  recipient: Address,\n  amount: UFix64,\n  vaultStoragePathIdentifier: String,\n  receiverPublicPathIdentifier: String\n) {\n  prepare(admin: auth(BorrowValue, Storage) &Account) {\n    let storagePath: StoragePath = StoragePath(identifier: vaultStoragePathIdentifier)!\n    let withdrawRef: auth(FungibleToken.Withdraw) &VaultShareToken.Vault = admin.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: storagePath)\n      ?? panic(\"admin share vault missing\")\n\n    let receiverPath: PublicPath = PublicPath(identifier: receiverPublicPathIdentifier)!\n    let cap: Capability<&{FungibleToken.Receiver}> = getAccount(recipient)\n      .capabilities.get<&{FungibleToken.Receiver}>(receiverPath)\n    if !cap.check() { panic(\"recipient receiver cap missing\") }\n    let receiver: &{FungibleToken.Receiver} = cap.borrow()\n      ?? panic(\"recipient receiver borrow failed\")\n\n    let payment: @{FungibleToken.Vault} <- withdrawRef.withdraw(amount: amount)\n    receiver.deposit(from: <-payment)\n  }\n}\n\n\n";
files["transactions/setup/user/setup-flow-vault.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\n\n// Sets up a FlowToken Vault for the signer if missing and publishes Receiver/Balance capabilities\ntransaction {\n    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n        if signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            signer.storage.save(<-vault, to: /storage/flowTokenVault)\n\n            let _unused1 = signer.capabilities.unpublish(/public/flowTokenReceiver)\n            signer.capabilities.publish(\n                signer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n                at: /public/flowTokenReceiver\n            )\n\n            let _unused2 = signer.capabilities.unpublish(/public/flowTokenBalance)\n            signer.capabilities.publish(\n                signer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n                at: /public/flowTokenBalance\n            )\n        }\n    }\n}\n\n\n";
files["transactions/setup/admin/fund-flow.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\n\n// Transfers FLOW from the signer to the specified recipient\n// Arguments:\n// - to: Address of the recipient (must have a FlowToken Receiver published)\n// - amount: UFix64 amount to transfer (e.g., 1000.00)\ntransaction(to: Address, amount: UFix64) {\n    prepare(signer: auth(BorrowValue) &Account) {\n        // Borrow an authorized reference with the Withdraw entitlement in Cadence 1.0\n        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Missing FlowToken Vault for signer\")\n\n        let receiver = getAccount(to)\n            .capabilities\n            .get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n            .borrow()\n            ?? panic(\"Recipient missing FlowToken Receiver capability\")\n\n        let payment <- vaultRef.withdraw(amount: amount)\n        receiver.deposit(from: <-payment)\n    }\n}\n\n\n";
files["transactions/setup/admin/setup-admin.cdc"] = "import \"Fractional\"\nimport \"FlowToken\"\nimport \"FlowTransactionSchedulerUtilsV2\"\nimport \"FeeParamsActivatorHandlerV2\"\nimport \"FungibleToken\"\n\ntransaction {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability, Storage) &Account) {\n    if signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) == nil {\n      signer.storage.save(<-Fractional.createAdmin(), to: /storage/FractionalAdmin)\n    }\n\n    // Initialize Platform Treasury FLOW vault and publish receiver cap (idempotent)\n    if signer.storage.borrow<&FlowToken.Vault>(from: /storage/PlatformTreasury_FLOW) == nil {\n      let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      signer.storage.save(<-v, to: /storage/PlatformTreasury_FLOW)\n    }\n    let _: Capability? = signer.capabilities.unpublish(/public/PlatformTreasury_FLOW)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&FlowToken.Vault>(/storage/PlatformTreasury_FLOW),\n      at: /public/PlatformTreasury_FLOW\n    )\n\n    // One-time funding: transfer 1000.00 FLOW from admin flow vault to PlatformTreasury (idempotent top-up)\n    let platRef: &FlowToken.Vault = signer.storage.borrow<&FlowToken.Vault>(from: /storage/PlatformTreasury_FLOW)\n      ?? panic(\"platform treasury missing after setup\")\n    if platRef.balance == 0.0 {\n      let withdrawRef: auth(FungibleToken.Withdraw) &FlowToken.Vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n        ?? panic(\"admin flowTokenVault missing; fund the admin first\")\n\n      // Transfer 1000.00 FLOW from admin flow vault to PlatformTreasury\n      let amount: UFix64 = 1000.0\n      \n      let payment: @{FungibleToken.Vault} <- withdrawRef.withdraw(amount: amount)\n      platRef.deposit(from: <-payment)\n    }\n\n    // Scheduler V2: ensure FeeActivator cap, Manager, and Handler are initialized (idempotent)\n    if signer.storage.borrow<&Fractional.FeeActivator>(from: Fractional.FeeActivatorStoragePath) == nil {\n      let a: @Fractional.FeeActivator <- Fractional.createFeeActivator()\n      signer.storage.save(<-a, to: Fractional.FeeActivatorStoragePath)\n    }\n    let _fa: Capability? = signer.capabilities.unpublish(Fractional.FeeActivatorPublicPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&Fractional.FeeActivator>(Fractional.FeeActivatorStoragePath),\n      at: Fractional.FeeActivatorPublicPath\n    )\n\n    if signer.storage.borrow<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(from: FlowTransactionSchedulerUtilsV2.managerStoragePath) == nil {\n      let m: @FlowTransactionSchedulerUtilsV2.ManagerImpl <- FlowTransactionSchedulerUtilsV2.createManager()\n      signer.storage.save(<-m, to: FlowTransactionSchedulerUtilsV2.managerStoragePath)\n    }\n    let _mp: Capability? = signer.capabilities.unpublish(FlowTransactionSchedulerUtilsV2.managerPublicPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(FlowTransactionSchedulerUtilsV2.managerStoragePath),\n      at: FlowTransactionSchedulerUtilsV2.managerPublicPath\n    )\n\n    if signer.storage.borrow<&FeeParamsActivatorHandlerV2.Handler>(from: /storage/FeeParamsActivatorHandlerV2) == nil {\n      let h: @FeeParamsActivatorHandlerV2.Handler <- FeeParamsActivatorHandlerV2.createHandler()\n      signer.storage.save(<-h, to: /storage/FeeParamsActivatorHandlerV2)\n    }\n    let _hp: Capability? = signer.capabilities.unpublish(/public/FeeParamsActivatorHandlerV2)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&FeeParamsActivatorHandlerV2.Handler>(/storage/FeeParamsActivatorHandlerV2),\n      at: /public/FeeParamsActivatorHandlerV2\n    )\n  }\n}\n\n\n\n\n";
files["transactions/scheduler/admin/init.cdc"] = "import Fractional from \"Fractional\"\nimport FlowTransactionScheduler from \"FlowTransactionScheduler\"\nimport FlowTransactionSchedulerUtils from \"FlowTransactionSchedulerUtils\"\nimport FeeParamsActivatorHandler from \"FeeParamsActivatorHandler\"\n\n// Admin init: publish FeeActivator cap and create scheduler Manager + handler\ntransaction {\n    prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability) &Account) {\n        // Ensure FeeActivator exists and publish restricted cap\n        if admin.storage.borrow<&Fractional.FeeActivator>(from: Fractional.FeeActivatorStoragePath) == nil {\n            let a: @Fractional.FeeActivator <- Fractional.createFeeActivator()\n            admin.storage.save(<-a, to: Fractional.FeeActivatorStoragePath)\n        }\n        // Re-publish public cap (idempotent)\n        let _: Capability? = admin.capabilities.unpublish(Fractional.FeeActivatorPublicPath)\n        // Publish concrete type; borrowers can request the restricted interface &{Fractional.FeeActivation}\n        admin.capabilities.publish(\n            admin.capabilities.storage.issue<&Fractional.FeeActivator>(Fractional.FeeActivatorStoragePath),\n            at: Fractional.FeeActivatorPublicPath\n        )\n\n        // Create or replace Manager\n        if admin.storage.borrow<&FlowTransactionSchedulerUtils.Manager>(from: /storage/TxSchedulerManager) == nil {\n            let m: @FlowTransactionSchedulerUtils.Manager <- FlowTransactionSchedulerUtils.createManager()\n            admin.storage.save(<-m, to: /storage/TxSchedulerManager)\n        }\n\n        // Create handler resource and store once (idempotent)\n        if admin.storage.borrow<&FeeParamsActivatorHandler.Handler>(from: /storage/FeeParamsActivatorHandler) == nil {\n            let h: @FeeParamsActivatorHandler.Handler <- FeeParamsActivatorHandler.createHandler()\n            admin.storage.save(<-h, to: /storage/FeeParamsActivatorHandler)\n        }\n\n        // Wire handler into manager using admin's published public path\n        let mRef: &FlowTransactionSchedulerUtils.Manager = admin.storage.borrow<&FlowTransactionSchedulerUtils.Manager>(from: /storage/TxSchedulerManager) ?? panic(\"missing manager\")\n        // Publish a public capability for the handler if not present\n        let _capHandlerUnpub: Capability? = admin.capabilities.unpublish(/public/FeeParamsActivatorHandler)\n        admin.capabilities.publish(\n            admin.capabilities.storage.issue<&FeeParamsActivatorHandler.Handler>(/storage/FeeParamsActivatorHandler),\n            at: /public/FeeParamsActivatorHandler\n        )\n        mRef.setHandler(owner: admin.address, pathIdentifier: \"FeeParamsActivatorHandler\")\n    }\n}\n\n\n";
files["transactions/scheduler/admin/initV2.cdc"] = "import FlowTransactionSchedulerUtilsV2 from \"FlowTransactionSchedulerUtilsV2\"\nimport FeeParamsActivatorHandlerV2 from \"FeeParamsActivatorHandlerV2\"\nimport Fractional from \"Fractional\"\n\ntransaction {\n    prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability) &Account) {\n        // Ensure FeeActivator exists and publish restricted cap (for handler borrow)\n        if admin.storage.borrow<&Fractional.FeeActivator>(from: Fractional.FeeActivatorStoragePath) == nil {\n            let a: @Fractional.FeeActivator <- Fractional.createFeeActivator()\n            admin.storage.save(<-a, to: Fractional.FeeActivatorStoragePath)\n        }\n        let _: Capability? = admin.capabilities.unpublish(Fractional.FeeActivatorPublicPath)\n        admin.capabilities.publish(\n            admin.capabilities.storage.issue<&Fractional.FeeActivator>(Fractional.FeeActivatorStoragePath),\n            at: Fractional.FeeActivatorPublicPath\n        )\n\n        // Ensure manager exists\n        if admin.storage.borrow<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(from: FlowTransactionSchedulerUtilsV2.managerStoragePath) == nil {\n            let m: @FlowTransactionSchedulerUtilsV2.ManagerImpl <- FlowTransactionSchedulerUtilsV2.createManager()\n            admin.storage.save(<-m, to: FlowTransactionSchedulerUtilsV2.managerStoragePath)\n            let _: Capability? = admin.capabilities.unpublish(FlowTransactionSchedulerUtilsV2.managerPublicPath)\n            admin.capabilities.publish(\n                admin.capabilities.storage.issue<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(FlowTransactionSchedulerUtilsV2.managerStoragePath),\n                at: FlowTransactionSchedulerUtilsV2.managerPublicPath\n            )\n        }\n\n        // Ensure handler exists and publish public cap\n        if admin.storage.borrow<&FeeParamsActivatorHandlerV2.Handler>(from: /storage/FeeParamsActivatorHandlerV2) == nil {\n            let h: @FeeParamsActivatorHandlerV2.Handler <- FeeParamsActivatorHandlerV2.createHandler()\n            admin.storage.save(<-h, to: /storage/FeeParamsActivatorHandlerV2)\n        }\n        let _capUnpub: Capability? = admin.capabilities.unpublish(/public/FeeParamsActivatorHandlerV2)\n        admin.capabilities.publish(\n            admin.capabilities.storage.issue<&FeeParamsActivatorHandlerV2.Handler>(/storage/FeeParamsActivatorHandlerV2),\n            at: /public/FeeParamsActivatorHandlerV2\n        )\n    }\n}\n\n\n";
files["transactions/scheduler/admin/schedule.cdc"] = "import FlowTransactionSchedulerUtils from \"FlowTransactionSchedulerUtils\"\n\n// Enqueue/Execute scheduled activation (emulator: executes immediately via Manager.invoke).\n// On mainnet, this would be created by a scheduler with an execution time.\ntransaction(vaultId: String) {\n    prepare(admin: auth(BorrowValue) &Account) {\n        let mRef: &FlowTransactionSchedulerUtils.Manager =\n            admin.storage.borrow<&FlowTransactionSchedulerUtils.Manager>(from: /storage/TxSchedulerManager)\n            ?? panic(\"missing manager\")\n\n        let data: {String: String} = {\"vaultId\": vaultId}\n        mRef.invoke(data: data)\n    }\n}\n\n\n";
files["transactions/scheduler/admin/scheduleV2.cdc"] = "import FlowTransactionScheduler from \"FlowTransactionScheduler\"\nimport FlowTransactionSchedulerUtilsV2 from \"FlowTransactionSchedulerUtilsV2\"\n\n// Official-style schedule tx: delaySeconds -> timestamp, priority, effort, data\ntransaction(delaySeconds: UFix64, priority: UInt8, executionEffort: UInt64, vaultId: String) {\n    prepare(admin: auth(BorrowValue) &Account) {\n        // Compute timestamp baseline: in emulator we can approximate using delaySeconds\n        let now: UFix64 = 0.0 // emulator shim; ManagerImpl ignores timestamp and executes immediately\n        let ts: UFix64 = now + delaySeconds\n\n        let mRef: &FlowTransactionSchedulerUtilsV2.ManagerImpl = admin.storage.borrow<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(from: FlowTransactionSchedulerUtilsV2.managerStoragePath)\n            ?? panic(\"missing manager V2\")\n\n        let handlerCap: Capability<&{FlowTransactionScheduler.TransactionHandler}> =\n            admin.capabilities.get<&{FlowTransactionScheduler.TransactionHandler}>(/public/FeeParamsActivatorHandlerV2)\n\n        let data: {String: String} = {\"vaultId\": vaultId}\n        let _id: UInt64 = mRef.schedule(\n            handlerCap: handlerCap,\n            data: data,\n            timestamp: ts,\n            priority: priority,\n            executionEffort: executionEffort\n        )\n    }\n}\n\n\n";
files["transactions/pools/user/AddLiquidity.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\nimport \"Fractional\"\n\n// Adds liquidity to a pool by withdrawing from the signer's share and FLOW vaults.\n// The LP vault is persisted at /storage/AMM_LP_<poolId> for the signer.\n\ntransaction(poolOwner: Address, poolPublicPathIdentifier: String, shareAmount: UFix64, flowAmount: UFix64, minLpOut: UFix64, vaultId: String) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    // Liveness guard: require LockBox custody is alive\n    let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n    if !Fractional.isCustodyAlive(vaultId: vaultId, custodian: v.custodian) { panic(\"vault custody not alive\") }\n\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let poolCap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !poolCap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = poolCap.borrow() ?? panic(\"invalid pool capability\")\n    let shareRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: VaultShareToken.getVaultStoragePath())\n      ?? panic(\"share vault not found\")\n    let flowRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"FLOW vault not found\")\n\n    let share <- shareRef.withdraw(amount: shareAmount) as! @VaultShareToken.Vault\n    let flow <- flowRef.withdraw(amount: flowAmount) as! @FlowToken.Vault\n    let lp: @ConstantProductAMM.LPVault <- p.addLiquidity(share: <-share, flow: <-flow, minLpOut: minLpOut, provider: signer.address)\n    let lpPath = StoragePath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    if signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath) == nil {\n      signer.storage.save(<-lp, to: lpPath)\n    } else {\n      let lpRef = signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath)!\n      lpRef.deposit(from: <-lp)\n    }\n\n    // Publish public capability so UI can read LP balance\n    let lpPubPath: PublicPath = PublicPath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    let _ = signer.capabilities.unpublish(lpPubPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&ConstantProductAMM.LPVault>(lpPath),\n      at: lpPubPath\n    )\n  }\n}\n\n\n";
files["transactions/pools/user/AddLiquidityOptimal.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\n\n// Adds liquidity using the optimal pair computed from desired amounts and current reserves.\ntransaction(poolOwner: Address, poolPublicPathIdentifier: String, shareDesired: UFix64, flowDesired: UFix64, minLpOut: UFix64) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let poolCap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !poolCap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = poolCap.borrow() ?? panic(\"invalid pool capability\")\n\n    let rs: {String: UFix64} = p.reserves()\n    let x0: UFix64 = rs[\"share\"]!\n    let y0: UFix64 = rs[\"flow\"]!\n\n    var shareAmt: UFix64 = shareDesired\n    var flowAmt: UFix64 = flowDesired\n\n    if x0 > 0.0 && y0 > 0.0 {\n      // Compute the smallest proportional unit using GCD on 8dp integers\n      let SCALE: UFix64 = 100000000.0\n      let X0: UInt64 = UInt64(x0 * SCALE)\n      let Y0: UInt64 = UInt64(y0 * SCALE)\n      let shareDesiredU: UInt64 = UInt64(shareDesired * SCALE)\n      let flowDesiredU: UInt64 = UInt64(flowDesired * SCALE)\n\n      if X0 > 0 && Y0 > 0 {\n        // Euclidean algorithm for GCD\n        fun gcd(_ a: UInt64, _ b: UInt64): UInt64 {\n          var x: UInt64 = a\n          var y: UInt64 = b\n          while y != 0 {\n            let r: UInt64 = x % y\n            x = y\n            y = r\n          }\n          return x\n        }\n\n        let g: UInt64 = gcd(X0, Y0)\n        let unitShare: UInt64 = X0 / g\n        let unitFlow: UInt64 = Y0 / g\n\n        let kShare: UInt64 = shareDesiredU / unitShare\n        let kFlow: UInt64 = flowDesiredU / unitFlow\n        let k: UInt64 = kShare < kFlow ? kShare : kFlow\n\n        if k == 0 { panic(\"inputs too small for pool ratio at 8dp; increase one side\") }\n\n        let sU: UInt64 = k * unitShare\n        let fU: UInt64 = k * unitFlow\n\n        shareAmt = UFix64(sU) / SCALE\n        flowAmt = UFix64(fU) / SCALE\n      }\n    }\n\n    let shareRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: VaultShareToken.getVaultStoragePath())\n      ?? panic(\"share vault not found\")\n    let flowRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"FLOW vault not found\")\n\n    let share: @VaultShareToken.Vault <- shareRef.withdraw(amount: shareAmt) as! @VaultShareToken.Vault\n    let flow: @FlowToken.Vault <- flowRef.withdraw(amount: flowAmt) as! @FlowToken.Vault\n\n    let lp: @ConstantProductAMM.LPVault <- p.addLiquidity(share: <-share, flow: <-flow, minLpOut: minLpOut, provider: signer.address)\n\n    let lpPath = StoragePath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    if signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath) == nil {\n      signer.storage.save(<-lp, to: lpPath)\n    } else {\n      let lpRef = signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath)!\n      lpRef.deposit(from: <-lp)\n    }\n\n    // Publish public capability so UI can read LP balance\n    let lpPubPath: PublicPath = PublicPath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    let _ = signer.capabilities.unpublish(lpPubPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&ConstantProductAMM.LPVault>(lpPath),\n      at: lpPubPath\n    )\n  }\n}\n";
files["transactions/pools/user/AddLiquidityWithChange.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\n\n// Simple add: user provides any amounts; pool uses exact proportional part and refunds the rest.\ntransaction(\n  poolOwner: Address,\n  poolPublicPathIdentifier: String,\n  shareIn: UFix64,\n  flowIn: UFix64,\n  minLpOut: UFix64\n) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let poolCap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !poolCap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = poolCap.borrow() ?? panic(\"invalid pool capability\")\n\n    // Withdraw requested amounts (either may be zero)\n    var share: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n    if shareIn > 0.0 {\n      let shareRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: VaultShareToken.getVaultStoragePath())\n        ?? panic(\"share vault not found\")\n      let tmp <- shareRef.withdraw(amount: shareIn)\n      let recvS = &share as &{FungibleToken.Receiver}\n      recvS.deposit(from: <-tmp)\n    }\n    var flow: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n    if flowIn > 0.0 {\n      let flowRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n        ?? panic(\"FLOW vault not found\")\n      let w: @FlowToken.Vault <- flowRef.withdraw(amount: flowIn) as! @FlowToken.Vault\n      let recv = &flow as &{FungibleToken.Receiver}\n      recv.deposit(from: <-w)\n    }\n\n    // Refund receivers\n    let shareRecv: Capability<&{FungibleToken.Receiver}> = signer.capabilities.get<&{FungibleToken.Receiver}>(VaultShareToken.getReceiverPublicPath())\n    if !shareRecv.check() { panic(\"share receiver not found\") }\n    let flowRecv: Capability<&{FungibleToken.Receiver}> = signer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    if !flowRecv.check() { panic(\"FLOW receiver not found\") }\n\n    // Support single-sided input: if one side is zero, swap half to create the pair\n    if share.balance > 0.0 && flow.balance == 0.0 {\n      let half: UFix64 = share.balance / 2.0\n      if half > 0.0 {\n        let sRefW: auth(FungibleToken.Withdraw) &{FungibleToken.Vault} = &share\n        let toSwap: @{FungibleToken.Vault} <- sRefW.withdraw(amount: half)\n        let res: @{String: {FungibleToken.Vault}} <- p.swapShareForFlow(input: <-toSwap, minOut: 0.0, trader: signer.address)\n        // Extract output and fee\n        let out <- res.remove(key: \"output\")\n          ?? panic(\"swapShareForFlow missing output\")\n        let fee <- res.remove(key: \"fee\")\n          ?? panic(\"swapShareForFlow missing fee\")\n        destroy res\n        // Deposit output (generic FT) into FLOW vault receiver\n        let fr: &{FungibleToken.Receiver} = &flow\n        fr.deposit(from: <-out)\n        // Internal routing: discard fee for now to avoid resource loss\n        destroy fee\n      }\n    } else if flow.balance > 0.0 && share.balance == 0.0 {\n      let halfF: UFix64 = flow.balance / 2.0\n      if halfF > 0.0 {\n        let fRefW: auth(FungibleToken.Withdraw) &FlowToken.Vault = &flow\n        let toSwapF: @FlowToken.Vault <- fRefW.withdraw(amount: halfF) as! @FlowToken.Vault\n        let res2: @{String: {FungibleToken.Vault}} <- p.swapFlowForShare(input: <-toSwapF, minOut: 0.0, trader: signer.address)\n        // Extract output and fee\n        let out2 <- res2.remove(key: \"output\")\n          ?? panic(\"swapFlowForShare missing output\")\n        let fee2 <- res2.remove(key: \"fee\")\n          ?? panic(\"swapFlowForShare missing fee\")\n        destroy res2\n        let sr: &{FungibleToken.Receiver} = &share \n        sr.deposit(from: <-out2)\n        destroy fee2\n      }\n    }\n\n    // Execute add-with-change\n    let lp: @ConstantProductAMM.LPVault <- p.addLiquidityWithChange(\n      share: <-share,\n      flow: <-flow,\n      minLpOut: minLpOut,\n      provider: signer.address,\n      shareRefund: shareRecv,\n      flowRefund: flowRecv\n    )\n\n    // Save/merge LP and publish public capability\n    let lpPath = StoragePath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    if signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath) == nil {\n      signer.storage.save(<-lp, to: lpPath)\n    } else {\n      let lpRef = signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath)!\n      lpRef.deposit(from: <-lp)\n    }\n    let lpPubPath: PublicPath = PublicPath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    let _ = signer.capabilities.unpublish(lpPubPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&ConstantProductAMM.LPVault>(lpPath),\n      at: lpPubPath\n    )\n  }\n}\n\n\n";
files["transactions/pools/user/CreatePool.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\n\n// Creates a pool for a given vaultId/symbol and feeBps.\n// Derives the concrete share vault type from the signer's existing share vault.\ntransaction(vaultId: String, symbol: String, feeBps: UInt64) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    let factoryRef: &ConstantProductAMM.Factory = ConstantProductAMM.borrowFactory()\n      ?? panic(\"AMM factory not found; deploy ConstantProductAMM and save factory at /storage/AMMFactoryV1\")\n\n    // Derive the concrete vault type for this vault's share FT by borrowing from storage\n    let shareRef: &{FungibleToken.Vault} = signer.storage.borrow<&{FungibleToken.Vault}>(from: VaultShareToken.getVaultStoragePath())\n      ?? panic(\"share vault not found; ensure your receiver/vault is set up for the share token\")\n    let empty: @{FungibleToken.Vault} <- shareRef.createEmptyVault()\n    let shareType: Type = empty.getType()\n    destroy empty\n\n    let _poolRef: &ConstantProductAMM.Pool = factoryRef.createPool(\n      account: signer,\n      vaultId: vaultId,\n      symbol: symbol,\n      feeBps: feeBps,\n      shareVaultType: shareType\n    )\n  }\n}\n\n\n";
files["transactions/pools/user/RemoveLiquidity.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\nimport \"Fractional\"\n\n// Removes liquidity by burning LP and returning both share and flow to signer.\n\ntransaction(poolOwner: Address, poolPublicPathIdentifier: String, lpAmount: UFix64, minShare: UFix64, minFlow: UFix64, vaultId: String) {\n  prepare(signer: auth(Storage, BorrowValue) &Account) {\n    // Liveness guard: require LockBox custody is alive\n    let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n    if !Fractional.isCustodyAlive(vaultId: vaultId, custodian: v.custodian) { panic(\"vault custody not alive\") }\n\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let poolCap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !poolCap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = poolCap.borrow() ?? panic(\"invalid pool capability\")\n    let lpPath: StoragePath = StoragePath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    let lpRef: &ConstantProductAMM.LPVault = signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath) ?? panic(\"LP vault not found\")\n\n    let lpToBurn: @ConstantProductAMM.LPVault <- lpRef.withdraw(amount: lpAmount)\n    let out: @{String: {FungibleToken.Vault}} <- p.removeLiquidity(lp: <-lpToBurn, minShare: minShare, minFlow: minFlow, provider: signer.address)\n    let outShare: @{FungibleToken.Vault} <- out.remove(key: \"share\") as! @{FungibleToken.Vault}\n    let outFlow: @{FungibleToken.Vault} <- out.remove(key: \"flow\") as! @{FungibleToken.Vault}\n    destroy out\n\n    // Deposit to signer’s standard vaults\n    let shareReceiver: &{FungibleToken.Receiver} = signer.capabilities.borrow<&{FungibleToken.Receiver}>(VaultShareToken.getReceiverPublicPath())\n      ?? panic(\"share receiver not found\")\n    shareReceiver.deposit(from: <-(outShare as! @VaultShareToken.Vault))\n    let flowReceiver: &{FungibleToken.Receiver} = signer.capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n      ?? panic(\"FLOW receiver not found\")\n    flowReceiver.deposit(from: <-(outFlow as! @FlowToken.Vault))\n  }\n}\n\n\n";
files["transactions/pools/user/SwapExactIn.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\n\n// Swaps exact-in from one token to the other with minOut protection.\n\ntransaction(poolOwner: Address, poolPublicPathIdentifier: String, inShare: Bool, amount: UFix64, minOut: UFix64) {\n  prepare(signer: auth(Storage, BorrowValue) &Account) {\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let poolCap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !poolCap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = poolCap.borrow() ?? panic(\"invalid pool capability\")\n    if inShare {\n      // Swap share -> flow using a provided share vault from signer storage (user should withdraw before submitting)\n      panic(\"Provide a transaction variant that carries @VaultShareToken.Vault as argument; not implemented in this generic tx\")\n    } else {\n      panic(\"Provide a transaction variant that carries @FlowToken.Vault as argument; not implemented in this generic tx\")\n    }\n  }\n}\n\n";
files["transactions/pools/user/SwapViaActions.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\nimport \"DeFiActions\"\nimport \"Fractional\"\nimport \"FungibleTokenConnectors\"\nimport \"FeeRouter\"\n\ntransaction(\n  poolOwner: Address,\n  poolPublicPathIdentifier: String,\n  directionTag: String, // \"share_to_flow\" | \"flow_to_share\"\n  amountIn: UFix64,\n  slippageBps: UInt64,\n  useID: Bool,\n  vaultId: String,  // NEW: needed for fee routing\n  platformAdmin: Address\n) {\n  prepare(signer: auth(Storage, BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n    // Liveness guard: require LockBox custody is alive\n    let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n    if !Fractional.isCustodyAlive(vaultId: vaultId, custodian: v.custodian) { panic(\"vault custody not alive\") }\n\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let cap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !cap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = cap.borrow() ?? panic(\"invalid pool capability\")\n\n    var direction: ConstantProductAMMSwapper.Direction = ConstantProductAMMSwapper.Direction.ShareToFlow\n    switch directionTag {\n      case \"share_to_flow\":\n        direction = ConstantProductAMMSwapper.Direction.ShareToFlow\n      case \"flow_to_share\":\n        direction = ConstantProductAMMSwapper.Direction.FlowToShare\n      default:\n        panic(\"invalid direction tag\")\n    }\n\n    var id: DeFiActions.UniqueIdentifier? = nil\n    if useID {\n      id = DeFiActions.createUniqueIdentifier()\n    }\n    if direction == ConstantProductAMMSwapper.Direction.ShareToFlow {\n      let shareRef = signer.storage\n        .borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(\n          from: VaultShareToken.getVaultStoragePath()\n        ) ?? panic(\"share vault not found\")\n      let input: @VaultShareToken.Vault <- shareRef.withdraw(amount: amountIn) as! @VaultShareToken.Vault\n      let baseSwapper1: {DeFiActions.Swapper} =\n        ConstantProductAMMSwapper.makeShareToFlowSwapper(poolCap: cap, trader: signer.address, id: id)\n      let swapper: {ConstantProductAMMSwapper.FeeSwapper} = baseSwapper1 as! {ConstantProductAMMSwapper.FeeSwapper}\n      // Compute platform fee on input and effective amount for quoting\n      let feeParams1: {String: UInt64} = Fractional.getAmmFeeParams(vaultId: p.vaultId)\n      let ammFeeBps1: UInt64 = feeParams1[\"ammFeeBps\"] ?? 0\n      let platformFee1: UFix64 = (amountIn * UFix64(ammFeeBps1)) / 10000.0\n      let effectiveIn1: UFix64 = amountIn > platformFee1 ? (amountIn - platformFee1) : 0.0\n\n      // Compute on-chain quote and slippage minOut using effective input\n      let qOut: {DeFiActions.Quote} = (baseSwapper1 as! ConstantProductAMMSwapper.AMMSwapper).quoteOut(forProvided: effectiveIn1, reverse: false)\n      let q: ConstantProductAMMSwapper.AMMQuote = qOut as! ConstantProductAMMSwapper.AMMQuote\n      let slipMul: UFix64 = (10000.0 - UFix64(slippageBps)) / 10000.0\n      let minOut: UFix64 = q.outAmount * slipMul\n      \n      // Get result dictionary with output and fee\n      let quoteMin: ConstantProductAMMSwapper.AMMQuote = ConstantProductAMMSwapper.AMMQuote(\n        inType: p.getShareVaultType(),\n        outType: Type<@FlowToken.Vault>(),\n        inAmount: effectiveIn1,\n        outAmount: minOut\n      )\n      let result: @{String: {FungibleToken.Vault}} <- swapper.swapWithFee(\n        quote: quoteMin as {DeFiActions.Quote},\n        inVault: <-input\n      )\n      let output: @FlowToken.Vault <- result.remove(key: \"output\")! as! @FlowToken.Vault\n      let fee: @{FungibleToken.Vault} <- result.remove(key: \"fee\")!\n      destroy result\n      \n      // Route AMM fee via FeeRouter using per‑vault share token ident\n      if fee.balance > 0.0 {\n        let shareIdent: String = VaultShareToken.name\n        FeeRouter.routeAmmFeeFromVault(\n          vaultId: vaultId,\n          tokenIdent: shareIdent,\n          fee: <-fee,\n          adminAddr: platformAdmin\n        )\n      } else {\n        destroy fee\n      }\n      \n      // Ensure FLOW vault and receiver are linked for first-time users\n      if signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n        let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n        signer.storage.save(<-v, to: /storage/flowTokenVault)\n        let _: Capability? = signer.capabilities.unpublish(/public/flowTokenReceiver)\n        signer.capabilities.publish(\n          signer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n          at: /public/flowTokenReceiver\n        )\n      } else {\n        let recvCap = signer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        if !recvCap.check() {\n          let _: Capability? = signer.capabilities.unpublish(/public/flowTokenReceiver)\n          signer.capabilities.publish(\n            signer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n            at: /public/flowTokenReceiver\n          )\n        }\n      }\n\n      // Verify slippage and deposit output (minOut already enforced in pool.swap)\n      let flowReceiver = signer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n      if !flowReceiver.check() { panic(\"FLOW receiver not linked\") }\n      flowReceiver.borrow()!.deposit(from: <-output)\n    } else if direction == ConstantProductAMMSwapper.Direction.FlowToShare {\n      let flowRef: auth(FungibleToken.Withdraw) &FlowToken.Vault =\n        signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n        ?? panic(\"FLOW vault not found\")\n      let input: @FlowToken.Vault <- flowRef.withdraw(amount: amountIn) as! @FlowToken.Vault\n      let baseSwapper3: {DeFiActions.Swapper} =\n        ConstantProductAMMSwapper.makeFlowToShareSwapper(poolCap: cap, trader: signer.address, id: id)\n      let swapper: {ConstantProductAMMSwapper.FeeSwapper} = baseSwapper3 as! {ConstantProductAMMSwapper.FeeSwapper}\n      // Compute platform fee on input and effective amount for quoting\n      let feeParams2: {String: UInt64} = Fractional.getAmmFeeParams(vaultId: p.vaultId)\n      let ammFeeBps2: UInt64 = feeParams2[\"ammFeeBps\"] ?? 0\n      let platformFee2: UFix64 = (amountIn * UFix64(ammFeeBps2)) / 10000.0\n      let effectiveIn2: UFix64 = amountIn > platformFee2 ? (amountIn - platformFee2) : 0.0\n\n      // Compute on-chain quote and slippage minOut using effective input\n      let qOut2: {DeFiActions.Quote} = (baseSwapper3 as! ConstantProductAMMSwapper.AMMSwapper).quoteOut(forProvided: effectiveIn2, reverse: false)\n      let q2: ConstantProductAMMSwapper.AMMQuote = qOut2 as! ConstantProductAMMSwapper.AMMQuote\n      let slipMul2: UFix64 = (10000.0 - UFix64(slippageBps)) / 10000.0\n      let minOut2: UFix64 = q2.outAmount * slipMul2\n      \n      // Get result dictionary with output and fee\n      let quoteMin2: ConstantProductAMMSwapper.AMMQuote = ConstantProductAMMSwapper.AMMQuote(\n        inType: Type<@FlowToken.Vault>(),\n        outType: p.getShareVaultType(),\n        inAmount: effectiveIn2,\n        outAmount: minOut2\n      )\n      let result: @{String: {FungibleToken.Vault}} <- swapper.swapWithFee(\n        quote: quoteMin2 as {DeFiActions.Quote},\n        inVault: <-input\n      )\n      let output: @VaultShareToken.Vault <- result.remove(key: \"output\")! as! @VaultShareToken.Vault\n      let fee: @FlowToken.Vault <- result.remove(key: \"fee\")! as! @FlowToken.Vault\n      destroy result\n      \n      // Route AMM fee via FeeRouter (FLOW)\n      if fee.balance > 0.0 {\n        FeeRouter.routeAmmFeeFromVault(\n          vaultId: vaultId,\n          tokenIdent: \"FLOW\",\n          fee: <-fee,\n          adminAddr: platformAdmin\n        )\n      } else {\n        destroy fee\n      }\n      \n      // Verify slippage and deposit output (minOut already enforced in pool.swap)\n      let shareReceiverPath = VaultShareToken.getReceiverPublicPath()\n      let shareReceiver = signer.capabilities.get<&{FungibleToken.Receiver}>(shareReceiverPath)\n      if !shareReceiver.check() { panic(\"Share receiver not linked\") }\n      shareReceiver.borrow()!.deposit(from: <-output)\n    } else {\n      panic(\"invalid direction\")\n    }\n  }\n}";
files["transactions/pools/user/ZapAddLiquidityViaActions.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\nimport \"Fractional\"\nimport \"DeFiActions\"\n\ntransaction(\n  poolOwner: Address,\n  poolPublicPathIdentifier: String,\n  amountFlow: UFix64,\n  minLpOut: UFix64,\n  vaultId: String,\n  platformAdmin: Address\n) {\n  prepare(signer: auth(Storage, BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n    // Pool\n    let publicPath: PublicPath = PublicPath(identifier: poolPublicPathIdentifier)!\n    let poolCap: Capability<&ConstantProductAMM.Pool> =\n      getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n    if !poolCap.check() { panic(\"invalid pool capability\") }\n    let p: &ConstantProductAMM.Pool = poolCap.borrow() ?? panic(\"invalid pool capability\")\n\n    // Ensure FLOW receiver\n    if signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n      let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      signer.storage.save(<-v, to: /storage/flowTokenVault)\n      let _ = signer.capabilities.unpublish(/public/flowTokenReceiver)\n      signer.capabilities.publish(\n        signer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n        at: /public/flowTokenReceiver\n      )\n    }\n\n    // Refund receivers for add-with-change\n    let shareRecv: Capability<&{FungibleToken.Receiver}> = signer.capabilities.get<&{FungibleToken.Receiver}>(VaultShareToken.getReceiverPublicPath())\n    if !shareRecv.check() { panic(\"share receiver not linked\") }\n    let flowRecv: Capability<&{FungibleToken.Receiver}> = signer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    if !flowRecv.check() { panic(\"FLOW receiver not linked\") }\n\n    // Withdraw FLOW input\n    let flowRef: auth(FungibleToken.Withdraw) &FlowToken.Vault =\n      signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"FLOW vault not found\")\n    var flowAll: @FlowToken.Vault <- flowRef.withdraw(amount: amountFlow) as! @FlowToken.Vault\n\n    // Compute split by reserves: target roughly 50/50 by current pool value\n    let res: {String: UFix64} = p.reserves()\n    let rsOpt = res[\"share\"]; let rfOpt = res[\"flow\"]\n    if rsOpt == nil || rfOpt == nil { panic(\"pool reserves missing\") }\n    let rs = rsOpt!; let rf = rfOpt!\n    let flowToSwap: UFix64 = amountFlow * rs / (rs + rf)\n    let flowForLP: UFix64 = amountFlow - flowToSwap\n\n    // Prepare split: take flowToSwap for swap leg\n    var shareSide: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n    if flowToSwap > 0.0 {\n      let fW: auth(FungibleToken.Withdraw) &FlowToken.Vault = &flowAll as auth(FungibleToken.Withdraw) &FlowToken.Vault\n      let toSwap: @FlowToken.Vault <- fW.withdraw(amount: flowToSwap) as! @FlowToken.Vault\n\n      // Swap FLOW -> SHARE via FeeSwapper\n\n      let swapper: {ConstantProductAMMSwapper.FeeSwapper} =\n        ConstantProductAMMSwapper.makeFlowToShareSwapper(\n          poolCap: poolCap,\n          trader: signer.address,\n          id: nil\n        ) as! {ConstantProductAMMSwapper.FeeSwapper}\n\n      let res2: @{String: {FungibleToken.Vault}} <- swapper.swapWithFee(quote: nil, inVault: <-toSwap)\n      let outShare <- res2.remove(key: \"output\")! // @VaultShareToken.Vault\n      let feeFlow <- res2.remove(key: \"fee\")! as! @FlowToken.Vault\n      destroy res2\n\n      // Fee routing: split FLOW fee into protocol/vault shares\n      let feeParams: {String: UInt64} = Fractional.getAmmFeeParams(vaultId: vaultId)\n      let vaultSplitBps: UInt64 = feeParams[\"ammFeeSplitVaultBps\"]!\n      let protocolSplitBps: UInt64 = feeParams[\"ammFeeSplitProtocolBps\"]!\n      let vaultShareAmt: UFix64 = (feeFlow.balance * UFix64(vaultSplitBps)) / 10000.0\n      let protocolShareAmt: UFix64 = feeFlow.balance - vaultShareAmt\n\n      // Ensure per-vault FLOW treasury exists under signer (publishes public receiver)\n      let vtIdent = \"VaultTreasury_FLOW_\".concat(vaultId)\n      let vtStorage: StoragePath = StoragePath(identifier: vtIdent)!\n      let vtPublic: PublicPath = PublicPath(identifier: vtIdent)!\n      if signer.storage.borrow<&FlowToken.Vault>(from: vtStorage) == nil {\n        let empty <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n        signer.storage.save(<-empty, to: vtStorage)\n      }\n      let _unpub = signer.capabilities.unpublish(vtPublic)\n      signer.capabilities.publish(\n        signer.capabilities.storage.issue<&FlowToken.Vault>(vtStorage),\n        at: vtPublic\n      )\n\n      // Withdraw and route\n      let feeRef: auth(FungibleToken.Withdraw) &FlowToken.Vault = &feeFlow as auth(FungibleToken.Withdraw) &FlowToken.Vault\n      if protocolShareAmt > 0.0 {\n        let prot <- feeRef.withdraw(amount: protocolShareAmt) as! @FlowToken.Vault\n        let platRecv: Capability<&{FungibleToken.Vault}> = getAccount(platformAdmin).capabilities.get<&{FungibleToken.Vault}>(/public/PlatformTreasury_FLOW)\n        platRecv.borrow()!.deposit(from: <-prot)\n      }\n      if vaultShareAmt > 0.0 {\n        let vPart <- feeRef.withdraw(amount: vaultShareAmt) as! @FlowToken.Vault\n        let vRecv: &{FungibleToken.Receiver} = signer.storage.borrow<&{FungibleToken.Receiver}>(from: vtStorage)!\n        vRecv.deposit(from: <-vPart)\n      }\n      destroy feeFlow\n\n      // Accumulate share side\n      let recvShare = &shareSide as &{FungibleToken.Receiver}\n      recvShare.deposit(from: <-outShare)\n    }\n\n    // flowForLP remains inside flowAll; ensure flowAll equals flowForLP or less due to rounding\n    // Proceed to add liquidity with change (refund caps already set)\n    let lp: @ConstantProductAMM.LPVault <- p.addLiquidityWithChange(\n      share: <-shareSide,\n      flow: <-flowAll,\n      minLpOut: minLpOut,\n      provider: signer.address,\n      shareRefund: shareRecv,\n      flowRefund: flowRecv\n    )\n\n    // Save/merge LP and publish cap\n    let lpPath = StoragePath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    if signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath) == nil {\n      signer.storage.save(<-lp, to: lpPath)\n    } else {\n      let lpRef = signer.storage.borrow<&ConstantProductAMM.LPVault>(from: lpPath)!\n      lpRef.deposit(from: <-lp)\n    }\n    let lpPubPath: PublicPath = PublicPath(identifier: \"AMM_LP_\".concat(p.poolId))!\n    let _ = signer.capabilities.unpublish(lpPubPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&ConstantProductAMM.LPVault>(lpPath),\n      at: lpPubPath\n    )\n  }\n}";
files["transactions/pools/admin/CreatePool.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"ConstantProductAMM\"\n\n// Creates a Share–FLOW pool and publishes its public capability.\n// Idempotence note: caller should ensure uniqueness by checking published cap for poolId beforehand.\n//\n// Args:\n// - vaultId: string identifier of the share vault (e.g., the fractional vault id)\n// - symbol: share token symbol (used by AMM for poolId)\n// - feeBps: pool fee in basis points\n\ntransaction(vaultId: String, symbol: String, feeBps: UInt64, shareVaultType: Type) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n    let factoryRef: &ConstantProductAMM.Factory = ConstantProductAMM.borrowFactory()\n      ?? panic(\"AMM factory not found; deploy ConstantProductAMM and save factory at /storage/AMMFactoryV1\")\n\n    // Create pool under signer and publish capability\n    let _poolRef: &ConstantProductAMM.Pool = factoryRef.createPool(account: signer, vaultId: vaultId, symbol: symbol, feeBps: feeBps, shareVaultType: shareVaultType)\n    // No further action needed; capability is published by factory\n  }\n}\n\n\n";
files["transactions/pools/admin/SeedLiquidity.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"Fractional\"\nimport \"ConstantProductAMM\"\n\ntransaction(poolOwner: Address, poolId: String, vaultId: String, shareAmount: UFix64, flowAmount: UFix64, minLpOut: UFix64) {\n  prepare(admin: auth(BorrowValue, Storage) &Account) {\n    let pubPath: PublicPath = ConstantProductAMM.getPoolPublicPath(poolId: poolId)\n    let cap: Capability<&ConstantProductAMM.Pool> = getAccount(poolOwner).capabilities.get<&ConstantProductAMM.Pool>(pubPath)\n    assert(cap.check(), message: \"invalid pool cap\")\n    let pool: &ConstantProductAMM.Pool = cap.borrow() ?? panic(\"bad pool\")\n\n    // Share escrow via dynamic storage path\n    let meta: {String: String} = Fractional.getVaultFT(vaultId: vaultId) ?? panic(\"vault FT meta missing\")\n    let shareStorage: StoragePath = StoragePath(identifier: meta[\"storage\"] ?? panic(\"storage ident missing\"))!\n    let shareEscrow: auth(FungibleToken.Withdraw) &{FungibleToken.Vault} = admin.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(from: shareStorage)\n      ?? panic(\"share escrow missing\")\n    let share: @{FungibleToken.Vault} <- shareEscrow.withdraw(amount: shareAmount) // @{FungibleToken.Vault}\n\n    // FLOW as concrete FlowToken\n    let flowRef: auth(FungibleToken.Withdraw) &FlowToken.Vault =\n      admin.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/PlatformTreasury_FLOW)\n      ?? panic(\"admin FLOW vault missing\")\n    let flowAny: @{FungibleToken.Vault} <- flowRef.withdraw(amount: flowAmount)\n    let flow: @FlowToken.Vault <- flowAny as! @FlowToken.Vault\n\n    let _lp: @ConstantProductAMM.LPVault <- pool.addLiquidity(share: <-share, flow: <-flow, minLpOut: minLpOut, provider: admin.address)\n    destroy _lp\n  }\n}   \n\n\n";
files["transactions/listings/user/cancel.cdc"] = "import \"FungibleToken\"\nimport \"FungibleTokenConnectors\"\nimport \"Fractional\"\n\ntransaction(\n  symbol: String,\n  vaultId: String,\n  listingId: String,\n  seller: Address,\n  shareAmount: UFix64\n) {\n  prepare(\n    sellerAcct: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account,\n    admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account\n  ) {\n    let storagePath: StoragePath = StoragePath(identifier: \"vault_\".concat(symbol))!\n    let receiverPath: PublicPath = PublicPath(identifier: \"receiver_\".concat(symbol))!\n    if !sellerAcct.capabilities.exists(receiverPath) {\n      panic(\"Setup Shares required: missing Receiver for seller\")\n    }\n    \n    let adminWithdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> = admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(storagePath)\n\n    let source: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(min: nil, withdrawVault: adminWithdrawCap, uniqueID: nil)\n    let sellerRecv: Capability<&{FungibleToken.Vault}> = sellerAcct.capabilities.storage.issue<&{FungibleToken.Vault}>(storagePath)\n    let sink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: sellerRecv, uniqueID: nil)\n    let shares: @{FungibleToken.Vault} <- source.withdrawAvailable(maxAmount: shareAmount)\n    if shares.balance > 0.0 {\n      sink.depositCapacity(from: &shares as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n    }\n    destroy shares\n    let adminRef = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing Fractional.Admin\")\n    adminRef.cancelListing(vaultId: vaultId, listingId: listingId)\n  }\n}\n\n\n";
files["transactions/listings/user/create_safe.cdc"] = "import \"FungibleToken\"\nimport \"FungibleTokenConnectors\"\nimport \"Fractional\"\nimport \"VaultShareToken\"\n\n/// Dual-authorizer listing creation that escrows seller shares into admin escrow atomically.\ntransaction(\n  symbol: String,\n  vaultId: String,\n  listingId: String,\n  priceAsset: String,\n  priceAmount: UFix64,\n  shareAmount: UFix64,\n  seller: Address\n) {\n  prepare(\n    sellerAcct: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account,\n    admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account\n  ) {\n    // Liveness guard: require LockBox custody is alive\n    let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n    if !Fractional.isCustodyAlive(vaultId: vaultId, custodian: v.custodian) { panic(\"vault custody not alive\") }\n\n    let shareStorage: StoragePath = StoragePath(identifier: \"vault_\".concat(symbol))!\n    let shareReceiver: PublicPath = PublicPath(identifier: \"receiver_\".concat(symbol))!\n\n    if !sellerAcct.capabilities.exists(shareReceiver) {\n      panic(\"Setup Shares required: missing Receiver for seller\")\n    }\n\n    // Ensure admin escrow exists and receiver/balance caps published\n    if admin.storage.borrow<&VaultShareToken.Vault>(from: shareStorage) == nil {\n      let empty: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let escrow: @VaultShareToken.Vault <- empty as! @VaultShareToken.Vault\n      admin.storage.save(<-escrow, to: shareStorage)\n    }\n    let _: Capability? = admin.capabilities.unpublish(shareReceiver)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&{FungibleToken.Receiver}>(shareStorage),\n      at: shareReceiver\n    )\n\n    // Also publish balance capability so UIs can read escrowed balance\n    let shareBalance: PublicPath = PublicPath(identifier: \"balance_\".concat(symbol))!\n    let __: Capability? = admin.capabilities.unpublish(shareBalance)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&{FungibleToken.Balance}>(shareStorage),\n      at: shareBalance\n    )\n\n    // Move seller shares -> admin escrow (direct withdraw/deposit)\n    let sellerVaultRef: auth(FungibleToken.Withdraw) &VaultShareToken.Vault =\n      sellerAcct.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: shareStorage)\n      ?? panic(\"seller share vault missing\")\n    let adminEscrowRef: &VaultShareToken.Vault =\n      admin.storage.borrow<&VaultShareToken.Vault>(from: shareStorage)\n      ?? panic(\"admin escrow missing\")\n    let pulled: @{FungibleToken.Vault} <- sellerVaultRef.withdraw(amount: shareAmount)\n    adminEscrowRef.deposit(from: <-pulled)\n\n    // Record listing\n    let adminRef: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing Fractional.Admin\")\n    adminRef.createListing(\n      vaultId: vaultId,\n      listingId: listingId,\n      priceAsset: priceAsset,\n      priceAmount: priceAmount,\n      amount: shareAmount,\n      seller: seller\n    )\n  }\n}\n\n\n";
files["transactions/listings/user/expire.cdc"] = "import \"FungibleToken\"\nimport \"FungibleTokenConnectors\"\nimport \"Fractional\"\n\ntransaction(\n  symbol: String,\n  vaultId: String,\n  listingId: String,\n  seller: Address,\n  shareAmount: UFix64\n) {\n  prepare(\n    admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account\n  ) {\n    let storagePath: StoragePath = StoragePath(identifier: \"vault_\".concat(symbol))!\n    let receiverPath: PublicPath = PublicPath(identifier: \"receiver_\".concat(symbol))!\n    let adminWithdrawCap = admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(storagePath)\n    let shares <- FungibleTokenConnectors.VaultSource(min: shareAmount, withdrawVault: adminWithdrawCap, uniqueID: nil)\n      .withdrawAvailable(maxAmount: shareAmount)\n    let recv = getAccount(seller).capabilities.get<&{FungibleToken.Receiver}>(receiverPath).borrow()\n      ?? panic(\"seller receiver missing\")\n    recv.deposit(from: <-shares)\n    let adminRef = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing Fractional.Admin\")\n    adminRef.expireListing(vaultId: vaultId, listingId: listingId)\n  }\n}\n\n\n";
files["transactions/listings/user/fill.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"Fractional\"\nimport \"FungibleTokenConnectors\"\nimport \"FeeRouter\"\n\n// Buyer pays seller with FLOW and buyer receives escrowed shares; optional fee routed to platform/vault treasuries\ntransaction(\n  symbol: String,\n  vaultId: String,\n  listingId: String,\n  seller: Address,\n  priceAmount: UFix64,\n  shareAmount: UFix64\n) {\n  prepare(\n    buyer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account,\n    admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account\n  ) {\n    if buyer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n      let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      buyer.storage.save(<-v, to: /storage/flowTokenVault)\n      buyer.capabilities.unpublish(/public/flowTokenReceiver)\n      buyer.capabilities.publish(\n        buyer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n        at: /public/flowTokenReceiver\n      )\n    }\n\n    let buyerWithdrawCap = buyer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(/storage/flowTokenVault)\n    let paySource = FungibleTokenConnectors.VaultSource(min: nil, withdrawVault: buyerWithdrawCap, uniqueID: nil)\n    let sellerRecv = getAccount(seller).capabilities.get<&{FungibleToken.Vault}>(/public/flowTokenReceiver)\n    let paySink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: sellerRecv, uniqueID: nil)\n    let funds <- paySource.withdrawAvailable(maxAmount: priceAmount)\n    if funds.balance <= 0.0 {\n      destroy funds\n      panic(\"insufficient buyer funds\")\n    } else {\n      while funds.balance > 0.0 {\n        let before = funds.balance\n        paySink.depositCapacity(from: &funds as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n        if funds.balance == before { panic(\"failed to deposit buyer funds\") }\n      }\n      destroy funds\n    }\n\n    // Route fees via FeeRouter (FLOW only here)\n    let buyerWithdrawCap2 = buyer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(/storage/flowTokenVault)\n    \n    FeeRouter.routeFee(\n      vaultId: vaultId,\n      tokenIdent: \"FLOW\",\n      amount: priceAmount,\n      source: buyerWithdrawCap2,\n      adminAddr: admin.address\n    )\n\n    let shareStorage: StoragePath = StoragePath(identifier: \"vault_\".concat(symbol))!\n    let shareReceiver: PublicPath = PublicPath(identifier: \"receiver_\".concat(symbol))!\n    let buyerRecvCap = buyer.capabilities.get<&{FungibleToken.Receiver}>(shareReceiver)\n    if !buyerRecvCap.check() {\n      panic(\"Setup Shares required: missing Receiver for buyer\")\n    }\n    let adminWithdrawCap = admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(shareStorage)\n    let shareSource = FungibleTokenConnectors.VaultSource(min: shareAmount, withdrawVault: adminWithdrawCap, uniqueID: nil)\n    let buyerShareRecv = buyer.capabilities.storage.issue<&{FungibleToken.Vault}>(shareStorage)\n    let shareSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: buyerShareRecv, uniqueID: nil)\n    let shares <- shareSource.withdrawAvailable(maxAmount: shareAmount)\n    if shares.balance <= 0.0 {\n      destroy shares\n      panic(\"insufficient escrowed shares for listing\")\n    } else {\n      while shares.balance > 0.0 {\n        let before = shares.balance\n        shareSink.depositCapacity(from: &shares as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n        if shares.balance == before { panic(\"failed to deposit shares to buyer\") }\n      }\n      destroy shares\n    }\n\n    let adminRef = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing Fractional.Admin\")\n    adminRef.fillListing(vaultId: vaultId, listingId: listingId, buyer: buyer.address)\n  }\n}\n\n\n";
files["transactions/listings/user/has-share-setup.cdc"] = "import \"FungibleToken\"\n\naccess(all) fun main(addr: Address, symbol: String): Bool {\n    let account = getAccount(addr)\n    let receiverPath = PublicPath(identifier: \"receiver_\".concat(symbol))!\n    let cap = account.capabilities.get<&{FungibleToken.Receiver}>(receiverPath)\n    return cap.check()\n}\n\n\n";
files["transactions/listings/user/pay.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\n\n// Buyer-only payment leg for a listing.\n// Sends FLOW to platform treasury escrow; admin later settles atomically (pay seller + transfer shares).\ntransaction(\n  vaultId: String,\n  listingId: String,\n  seller: Address,\n  priceAmount: UFix64,\n  platformAdmin: Address\n) {\n  prepare(buyer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n    // Ensure buyer FLOW vault/receiver\n    if buyer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n      let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      buyer.storage.save(<-v, to: /storage/flowTokenVault)\n      let _: Capability? = buyer.capabilities.unpublish(/public/flowTokenReceiver)\n      buyer.capabilities.publish(\n        buyer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n        at: /public/flowTokenReceiver\n      )\n    }\n\n    // Move funds to platform escrow (treasury) for atomic settlement later\n    let withdrawRef: auth(FungibleToken.Withdraw) &FlowToken.Vault =\n      buyer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"FLOW vault not found\")\n    let out: @FlowToken.Vault <- withdrawRef.withdraw(amount: priceAmount) as! @FlowToken.Vault\n    let platRecv: &{FungibleToken.Receiver} = getAccount(platformAdmin)\n      .capabilities\n      .get<&{FungibleToken.Receiver}>(/public/PlatformTreasury_FLOW)\n      .borrow() ?? panic(\"platform FLOW treasury receiver missing\")\n    platRecv.deposit(from: <-out)\n  }\n}\n\n\n";
files["transactions/listings/user/setup-shares.cdc"] = "import \"FungibleToken\"\nimport \"VaultShareToken\"\n\n// Sets up share vault and public capabilities using the token's configured paths.\ntransaction {\n  prepare(acct: auth(Storage, BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability) &Account) {\n    let storagePath: StoragePath = VaultShareToken.getVaultStoragePath()\n    let receiverPath: PublicPath = VaultShareToken.getReceiverPublicPath()\n    let balancePath: PublicPath = VaultShareToken.getBalancePublicPath()\n\n    if acct.storage.borrow<&VaultShareToken.Vault>(from: storagePath) == nil {\n      let any: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let v: @VaultShareToken.Vault <- any as! @VaultShareToken.Vault\n      acct.storage.save(<-v, to: storagePath)\n    }\n    if !acct.capabilities.exists(receiverPath) {\n      acct.capabilities.unpublish(receiverPath)\n      acct.capabilities.publish(\n        acct.capabilities.storage.issue<&{FungibleToken.Receiver}>(storagePath),\n        at: receiverPath\n      )\n    }\n    if !acct.capabilities.exists(balancePath) {\n      acct.capabilities.unpublish(balancePath)\n      acct.capabilities.publish(\n        acct.capabilities.storage.issue<&VaultShareToken.Vault>(storagePath),\n        at: balancePath\n      )\n    }\n  }\n}";
files["transactions/listings/user/swapFill.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"Fractional\"\nimport \"FungibleTokenConnectors\"\nimport \"FeeRouter\"\nimport \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\nimport \"VaultShareToken\"\nimport \"DeFiActions\"\n\n// Optional AMM pre-swap on our platform (share -> flow) before paying seller\ntransaction(\n  pool: Capability<&ConstantProductAMM.Pool>,\n  swapShareAmount: UFix64,\n  minFlowOut: UFix64,\n  symbol: String,\n  seller: Address,\n  priceAmount: UFix64,\n  shareAmount: UFix64,\n  vaultId: String,\n  listingId: String\n) {\n  prepare(\n    buyer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account,\n    admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account\n  ) {\n    // Liveness guard: require LockBox custody is alive\n    let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n    if !Fractional.isCustodyAlive(vaultId: vaultId, custodian: v.custodian) { panic(\"vault custody not alive\") }\n\n    if buyer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n      let v: @FlowToken.Vault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n      buyer.storage.save(<-v, to: /storage/flowTokenVault)\n      let _ = buyer.capabilities.unpublish(/public/flowTokenReceiver)\n      buyer.capabilities.publish(\n        buyer.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault),\n        at: /public/flowTokenReceiver\n      )\n    }\n\n    // Optional: swap share -> flow on our AMM before payment\n    if swapShareAmount > 0.0 {\n      let p: &ConstantProductAMM.Pool = pool.borrow() ?? panic(\"invalid pool capability\")\n      let shareRef: auth(FungibleToken.Withdraw) &VaultShareToken.Vault = buyer.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: VaultShareToken.getVaultStoragePath())\n        ?? panic(\"share vault not found\")\n      let input: @VaultShareToken.Vault <- shareRef.withdraw(amount: swapShareAmount) as! @VaultShareToken.Vault\n      let swapper: {DeFiActions.Swapper} = ConstantProductAMMSwapper.makeShareToFlowSwapper(poolCap: pool, trader: buyer.address, id: nil)\n      let q: {DeFiActions.Quote} = swapper.quoteOut(forProvided: swapShareAmount, reverse: false)\n      if q.outAmount < minFlowOut { panic(\"slippage: quoted < min\") }\n      let out: @{FungibleToken.Vault} <- swapper.swap(quote: q, inVault: <-input)\n      let casted: @FlowToken.Vault <- out as! @FlowToken.Vault\n      let flowRecv = buyer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n      if !flowRecv.check() { panic(\"FLOW receiver not linked\") }\n      flowRecv.borrow()!.deposit(from: <-casted)\n      // p is kept borrowed to satisfy reference usage; not used further\n      let _ = p\n    }\n\n    // Pay seller in FLOW\n    let withdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> = buyer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(/storage/flowTokenVault)\n    let source: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(min: nil, withdrawVault: withdrawCap, uniqueID: nil)\n    let sellerDepositCap: Capability<&{FungibleToken.Vault}> = getAccount(seller).capabilities.get<&{FungibleToken.Vault}>(/public/flowTokenReceiver)\n    let sink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: sellerDepositCap, uniqueID: nil)\n    let tokens: @{FungibleToken.Vault} <- source.withdrawAvailable(maxAmount: priceAmount)\n    sink.depositCapacity(from: &tokens as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n    destroy tokens\n\n    // Route listing taker fee via FeeRouter (FLOW)\n    let buyerWithdrawCap2: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> = buyer.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(/storage/flowTokenVault)\n    FeeRouter.routeFee(\n      vaultId: vaultId,\n      tokenIdent: \"FLOW\",\n      amount: priceAmount,\n      source: buyerWithdrawCap2,\n      adminAddr: admin.address\n    )\n\n    let shareStorage: StoragePath = StoragePath(identifier: \"vault_\".concat(symbol))!\n    let shareReceiver: PublicPath = PublicPath(identifier: \"receiver_\".concat(symbol))!\n    if !buyer.capabilities.exists(shareReceiver) {\n      panic(\"Setup Shares required: missing Receiver for buyer\")\n    }\n    let adminWithdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> = admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(shareStorage)\n    let shareSource: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(min: shareAmount, withdrawVault: adminWithdrawCap, uniqueID: nil)\n    let buyerShareRecv: Capability<&{FungibleToken.Vault}> = buyer.capabilities.storage.issue<&{FungibleToken.Vault}>(shareStorage)\n    let shareSink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: buyerShareRecv, uniqueID: nil)\n    let shares: @{FungibleToken.Vault} <- shareSource.withdrawAvailable(maxAmount: shareAmount)\n    if shares.balance <= 0.0 {\n      destroy shares\n      panic(\"insufficient escrowed shares for listing\")\n    } else {\n      while shares.balance > 0.0 {\n        let before: UFix64 = shares.balance\n        shareSink.depositCapacity(from: &shares as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n        if shares.balance == before { panic(\"failed to deposit shares to buyer\") }\n      }\n      destroy shares\n    }\n\n    let adminRef: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing admin\")\n    adminRef.fillListing(vaultId: vaultId, listingId: listingId, buyer: buyer.address)\n  }\n}\n\n\n";
files["transactions/listings/admin/cancel.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  listingId: String\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.cancelListing(\n      vaultId: vaultId,\n      listingId: listingId\n    )\n  }\n}\n\n\n";
files["transactions/listings/admin/create.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  listingId: String,\n  priceAsset: String,\n  priceAmount: UFix64,\n  shareAmount: UFix64,\n  seller: Address\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.createListing(\n      vaultId: vaultId,\n      listingId: listingId,\n      priceAsset: priceAsset,\n      priceAmount: priceAmount,\n      amount: shareAmount,\n      seller: seller\n    )\n  }\n}\n\n\n";
files["transactions/listings/admin/expire.cdc"] = "import \"FungibleToken\"\nimport \"FungibleTokenConnectors\"\nimport \"VaultShareToken\"\nimport \"Fractional\"\n\n// Admin expires a listing. Shares are returned from admin escrow to seller via Actions,\n// then admin marks the listing expired.\ntransaction(\n    vaultId: String,\n    listingId: String,\n    seller: Address,\n    shareAmount: UFix64\n) {\n    prepare(\n        admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account\n    ) {\n        let storagePath: StoragePath = VaultShareToken.getVaultStoragePath()\n\n        // Source: admin escrow → withdraw shares\n        let adminWithdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> = admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(storagePath)\n        let source: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(min: shareAmount, withdrawVault: adminWithdrawCap, uniqueID: nil)\n\n        // Sink: seller receiver (must exist; require setup done)\n        let sellerRecv: Capability<&{FungibleToken.Vault}> = getAccount(seller).capabilities.get<&{FungibleToken.Vault}>(VaultShareToken.getReceiverPublicPath())\n        let sink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: sellerRecv, uniqueID: nil)\n\n        let shares: @{FungibleToken.Vault} <- source.withdrawAvailable(maxAmount: shareAmount)\n        sink.depositCapacity(from: &shares as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n        destroy shares\n\n        // Mark expired\n        let adminRef = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing Fractional.Admin\")\n        adminRef.expireListing(vaultId: vaultId, listingId: listingId)\n    }\n}\n\n\n";
files["transactions/listings/admin/fill.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  listingId: String,\n  buyer: Address\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.fillListing(\n      vaultId: vaultId,\n      listingId: listingId,\n      buyer: buyer\n    )\n  }\n}\n\n\n";
files["transactions/listings/admin/settle-fill.cdc"] = "import \"FungibleToken\"\nimport \"FungibleTokenConnectors\"\nimport \"VaultShareToken\"\nimport \"Fractional\"\nimport \"FlowToken\"\nimport \"FeeRouter\"\n\n// Admin-only settlement: move escrowed shares to buyer and mark listing filled.\ntransaction(\n  symbol: String,\n  vaultId: String,\n  listingId: String,\n  buyer: Address,\n  shareAmount: UFix64,\n  priceAmount: UFix64,\n  seller: Address\n) {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    let storagePath: StoragePath = VaultShareToken.getVaultStoragePath()\n\n    // Withdraw from admin escrow using Actions\n    let adminWithdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> =\n      admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(storagePath)\n    let source: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(min: shareAmount, withdrawVault: adminWithdrawCap, uniqueID: nil)\n    let buyerRecvCap: Capability<&{FungibleToken.Vault}> = getAccount(buyer)\n      .capabilities.get<&{FungibleToken.Vault}>(VaultShareToken.getReceiverPublicPath())\n    let sink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: buyerRecvCap, uniqueID: nil)\n\n    let shares: @{FungibleToken.Vault} <- source.withdrawAvailable(maxAmount: shareAmount)\n    sink.depositCapacity(from: &shares as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n    destroy shares\n\n    // Pay seller from platform escrow and route fee\n    let platStorage: StoragePath = StoragePath(identifier: \"PlatformTreasury_FLOW\")!\n    let platWithdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> =\n      admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(platStorage)\n\n    // Compute fee splits\n    let splits: {String: UFix64} = FeeRouter.computeFeeSplits(vaultId: vaultId, amount: priceAmount)\n    let feeAmount: UFix64 = splits[\"feeAmount\"] ?? 0.0\n    let sellerAmount: UFix64 = priceAmount - feeAmount\n\n    if sellerAmount > 0.0 {\n      let src: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(min: sellerAmount, withdrawVault: platWithdrawCap, uniqueID: nil)\n      let sellerRecv: Capability<&{FungibleToken.Vault}> = getAccount(seller).capabilities.get<&{FungibleToken.Vault}>(/public/flowTokenReceiver)\n      let sink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(max: nil, depositVault: sellerRecv, uniqueID: nil)\n      let funds: @{FungibleToken.Vault} <- src.withdrawAvailable(maxAmount: sellerAmount)\n      sink.depositCapacity(from: &funds as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n      destroy funds\n    }\n\n    if feeAmount > 0.0 {\n      FeeRouter.routeFee(\n        vaultId: vaultId,\n        tokenIdent: \"FLOW\",\n        amount: feeAmount,\n        source: platWithdrawCap,\n        adminAddr: admin.address\n      )\n    }\n\n    // Mark listing filled\n    let a: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing admin\")\n    a.fillListing(vaultId: vaultId, listingId: listingId, buyer: buyer)\n  }\n}\n\n\n";
files["transactions/governance/admin/buyout-finalize.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  proposalId: String,\n  result: String\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.finalizeBuyout(\n      vaultId: vaultId,\n      proposalId: proposalId,\n      result: result\n    )\n  }\n}\n\n\n\n\n";
files["transactions/governance/admin/buyout-propose.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  proposalId: String,\n  asset: String,\n  amount: UFix64,\n  quorumPercent: UInt64,\n  supportPercent: UInt64,\n  expiresAt: UInt64\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.proposeBuyout(\n      vaultId: vaultId,\n      proposalId: proposalId,\n      asset: asset,\n      amount: amount,\n      quorumPercent: quorumPercent,\n      supportPercent: supportPercent,\n      expiresAt: expiresAt\n    )\n  }\n}\n\n\n\n\n";
files["transactions/governance/admin/buyout-vote.cdc"] = "import \"Fractional\"\n\ntransaction(\n  vaultId: String,\n  proposalId: String,\n  forVotes: UFix64,\n  againstVotes: UFix64\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.voteBuyout(\n      vaultId: vaultId,\n      proposalId: proposalId,\n      forVotes: forVotes,\n      againstVotes: againstVotes\n    )\n  }\n}\n\n\n\n\n";
files["transactions/example-nft/user/setup-collection.cdc"] = "import \"NonFungibleToken\"\nimport \"ExampleNFT\"\n\ntransaction {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {\n    if signer.storage.borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath) == nil {\n      let collection: @{NonFungibleToken.Collection} <- ExampleNFT.createEmptyCollection(nftType: Type<@ExampleNFT.NFT>())\n      signer.storage.save(<-collection, to: ExampleNFT.CollectionStoragePath)\n      let _: Capability? = signer.capabilities.unpublish(ExampleNFT.CollectionPublicPath)\n      let cap: Capability<&ExampleNFT.Collection> = signer.capabilities.storage.issue<&ExampleNFT.Collection>(ExampleNFT.CollectionStoragePath)\n      signer.capabilities.publish(cap, at: ExampleNFT.CollectionPublicPath)\n    }\n  }\n}";
files["transactions/example-nft/admin/mint-to.cdc"] = "import \"MetadataViews\"\nimport \"ExampleNFT\"\n\ntransaction(recipient: Address, name: String, description: String, thumbnail: String) {\n  prepare(signer: auth(Storage) &Account) {\n    let minterRef: &ExampleNFT.NFTMinter = signer.storage.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)\n      ?? panic(\"missing ExampleNFT minter\")\n    let royalties: [MetadataViews.Royalty] = []\n    let nft: @ExampleNFT.NFT <- minterRef.mintNFT(name: name, description: description, thumbnail: thumbnail, royalties: royalties)\n    let recipientAcct: &Account = getAccount(recipient)\n    let colCap: Capability<&ExampleNFT.Collection> = recipientAcct.capabilities.get<&ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)\n    let colRef: &ExampleNFT.Collection = colCap.borrow() ?? panic(\"recipient missing ExampleNFT.Collection public capability\")\n    colRef.deposit(token: <- nft)\n  }\n}\n\n\n\n\n\n";
files["transactions/distributions/user/claim.cdc"] = "import \"Fractional\"\n\ntransaction(\n  programId: String,\n  amount: UFix64\n) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.payoutClaimed(\n      programId: programId,\n      account: signer.address,\n      amount: amount\n    )\n  }\n}\n\n\n\n\n";
files["transactions/distributions/scheduler/execute.cdc"] = "import \"FungibleToken\"\nimport \"FungibleTokenConnectors\"\nimport \"Fractional\"\n// VaultShareToken import will be aliased dynamically by off-chain service\nimport \"VaultShareToken\"\n\n// Recipient struct for distribution (only address, amounts calculated evenly)\naccess(all) struct Recipient {\n  access(all) let Address: Address\n  \n  access(all) init(Address: Address) {\n    self.Address = Address\n  }\n}\n\n// Execute distribution: distribute shares evenly from escrow to recipients\ntransaction(\n  programId: String,\n  vaultId: String,\n  totalAmount: UFix64,\n  recipients: [Recipient]\n) {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability, Storage) &Account) {\n    // Validate we have recipients\n    if recipients.length == 0 {\n      panic(\"no recipients provided\")\n    }\n    \n    // Get vault FT metadata\n    let ftMeta: {String: String}? = Fractional.getVaultFT(vaultId: vaultId)\n    if ftMeta == nil { panic(\"vault FT not registered\") }\n    \n    let ftContractName: String = ftMeta![\"name\"]!\n    let receiverPathIdentifier: String = ftMeta![\"receiver\"]!\n    let vaultReceiverPath: PublicPath = PublicPath(identifier: receiverPathIdentifier)!\n    \n    // Distribution escrow path: DistributionEscrow_<CONTRACT_NAME>_<programId>\n    let escrowStorageIdent: String = \"DistributionEscrow_\".concat(ftContractName).concat(\"_\").concat(programId)\n    let escrowStoragePath: StoragePath = StoragePath(identifier: escrowStorageIdent)!\n    \n    // Verify escrow has sufficient balance (safety check)\n    let escrowVault: &{FungibleToken.Vault} = admin.storage.borrow<&{FungibleToken.Vault}>(from: escrowStoragePath)\n      ?? panic(\"distribution escrow not found\")\n    \n    if escrowVault.balance < totalAmount {\n      panic(\"insufficient escrow balance\")\n    }\n    \n    // Calculate amount per recipient (even division)\n    let amountPerRecipient: UFix64 = totalAmount / UFix64(recipients.length)\n    \n    // Distribute shares to recipients\n    var i = 0\n    while i < recipients.length {\n      let recipient: Address = recipients[i].Address\n      \n      // Withdraw from distribution escrow\n      let escrowWithdrawCap: Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}> =\n        admin.capabilities.storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Vault}>(escrowStoragePath)\n      let source: FungibleTokenConnectors.VaultSource = FungibleTokenConnectors.VaultSource(\n        min: amountPerRecipient,\n        withdrawVault: escrowWithdrawCap,\n        uniqueID: nil\n      )\n      \n      // Get recipient receiver\n      let recipientRecv: Capability<&{FungibleToken.Vault}> = getAccount(recipient)\n        .capabilities.get<&{FungibleToken.Vault}>(vaultReceiverPath)\n      if recipientRecv == nil {\n        panic(\"recipient receiver not set up\")\n      }\n      let sink: FungibleTokenConnectors.VaultSink = FungibleTokenConnectors.VaultSink(\n        max: nil,\n        depositVault: recipientRecv,\n        uniqueID: nil\n      )\n      \n      let shares: @{FungibleToken.Vault} <- source.withdrawAvailable(maxAmount: amountPerRecipient)\n      sink.depositCapacity(from: &shares as auth(FungibleToken.Withdraw) &{FungibleToken.Vault})\n      destroy shares\n      \n      // Emit claim event\n      let fractionalAdmin: &Fractional.Admin = admin.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin) ?? panic(\"missing admin\")\n      fractionalAdmin.payoutClaimed(\n        programId: programId,\n        account: recipient,\n        amount: amountPerRecipient\n      )\n      \n      i = i + 1\n    }\n  }\n}\n\n";
files["transactions/distributions/admin/init-handler.cdc"] = "import FlowTransactionSchedulerUtilsV2 from \"FlowTransactionSchedulerUtilsV2\"\nimport DistributionHandler from \"DistributionHandler\"\n\ntransaction {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability) &Account) {\n    // Ensure manager exists\n    if admin.storage.borrow<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(from: FlowTransactionSchedulerUtilsV2.managerStoragePath) == nil {\n      let m: @FlowTransactionSchedulerUtilsV2.ManagerImpl <- FlowTransactionSchedulerUtilsV2.createManager()\n      admin.storage.save(<-m, to: FlowTransactionSchedulerUtilsV2.managerStoragePath)\n      let _: Capability? = admin.capabilities.unpublish(FlowTransactionSchedulerUtilsV2.managerPublicPath)\n      admin.capabilities.publish(\n        admin.capabilities.storage.issue<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(FlowTransactionSchedulerUtilsV2.managerStoragePath),\n        at: FlowTransactionSchedulerUtilsV2.managerPublicPath\n      )\n    }\n\n    // Ensure handler exists and publish public cap\n    if admin.storage.borrow<&DistributionHandler.Handler>(from: /storage/DistributionHandler) == nil {\n      let h: @DistributionHandler.Handler <- DistributionHandler.createHandler()\n      admin.storage.save(<-h, to: /storage/DistributionHandler)\n    }\n    let _capUnpub: Capability? = admin.capabilities.unpublish(/public/DistributionHandler)\n    admin.capabilities.publish(\n      admin.capabilities.storage.issue<&DistributionHandler.Handler>(/storage/DistributionHandler),\n      at: /public/DistributionHandler\n    )\n  }\n}\n\n";
files["transactions/distributions/admin/schedule.cdc"] = "import \"Fractional\"\nimport \"FungibleToken\"\nimport FlowTransactionScheduler from \"FlowTransactionScheduler\"\nimport FlowTransactionSchedulerUtilsV2 from \"FlowTransactionSchedulerUtilsV2\"\nimport DistributionHandler from \"DistributionHandler\"\n// VaultShareToken import will be aliased dynamically\nimport \"VaultShareToken\"\n\ntransaction(\n  vaultId: String,\n  programId: String,\n  asset: String,\n  totalAmount: UFix64,\n  schedule: String,\n  startsAt: UInt64,\n  endsAt: UInt64\n) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, PublishCapability, UnpublishCapability, Storage) &Account) {\n    // Get vault FT metadata to determine contract name for escrow path\n    let ftMeta: {String: String}? = Fractional.getVaultFT(vaultId: vaultId)\n    if ftMeta == nil { panic(\"vault FT not registered\") }\n    \n    let ftContractName: String = ftMeta![\"name\"]!\n    \n    // Distribution escrow path: DistributionEscrow_<CONTRACT_NAME>_<programId>\n    let escrowStorageIdent: String = \"DistributionEscrow_\".concat(ftContractName).concat(\"_\").concat(programId)\n    let escrowStoragePath: StoragePath = StoragePath(identifier: escrowStorageIdent)!\n    let escrowPublicPath: PublicPath = PublicPath(identifier: escrowStorageIdent)!\n    \n    // Ensure distribution escrow vault exists\n    if signer.storage.borrow<&{FungibleToken.Vault}>(from: escrowStoragePath) == nil {\n      let empty: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      signer.storage.save(<-empty, to: escrowStoragePath)\n    }\n    \n    // Publish receiver capability for escrow (needed for minting into it)\n    let _: Capability? = signer.capabilities.unpublish(escrowPublicPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&{FungibleToken.Receiver}>(escrowStoragePath),\n      at: escrowPublicPath\n    )\n    \n    // Mint totalAmount into distribution escrow\n    // This will fail if it would exceed maxSupply (max supply check happens here)\n    let adminRef = VaultShareToken.borrowAdmin() ?? panic(\"missing VaultShareToken.Admin\")\n    let escrowRecv: Capability<&{FungibleToken.Vault}>? = signer.capabilities.get<&{FungibleToken.Vault}>(escrowPublicPath)\n    if escrowRecv == nil {\n      panic(\"escrow receiver capability missing\")\n    }\n    \n    adminRef.mint(to: escrowRecv!.borrow() ?? panic(\"escrow receiver missing\"), amount: totalAmount)\n    \n    // Emit DistributionScheduled event\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.scheduleDistribution(\n      vaultId: vaultId,\n      programId: programId,\n      asset: asset,\n      totalAmount: totalAmount,\n      schedule: schedule,\n      startsAt: startsAt,\n      endsAt: endsAt\n    )\n    \n    // Create scheduled transaction for execution at startsAt\n    let mRef: &FlowTransactionSchedulerUtilsV2.ManagerImpl = signer.storage.borrow<&FlowTransactionSchedulerUtilsV2.ManagerImpl>(from: FlowTransactionSchedulerUtilsV2.managerStoragePath)\n      ?? panic(\"missing scheduler manager\")\n    \n    let handlerCap: Capability<&{FlowTransactionScheduler.TransactionHandler}>? =\n      signer.capabilities.get<&{FlowTransactionScheduler.TransactionHandler}>(/public/DistributionHandler)\n    if handlerCap == nil {\n      panic(\"missing DistributionHandler capability\")\n    }\n    \n    let data: {String: String} = {\n      \"programId\": programId,\n      \"vaultId\": vaultId\n    }\n    \n    // Convert startsAt (UInt64 timestamp) to UFix64 for scheduler\n    let timestamp: UFix64 = UFix64(startsAt)\n    \n    let _id: UInt64 = mRef.schedule(\n      handlerCap: handlerCap!,\n      data: data,\n      timestamp: timestamp,\n      priority: 0,\n      executionEffort: 1000\n    )\n  }\n}\n\n\n\n\n";
files["transactions/diagnostic/admin/emit-shares-minted.cdc"] = "import \"Fractional\"\n\ntransaction(symbol: String, accounts: [Address], amounts: [UFix64]) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.emitSharesMinted(symbol: symbol, accounts: accounts, amounts: amounts)\n  }\n}\n\n\n";
files["transactions/diagnostic/admin/emit-transfer.cdc"] = "import \"Fractional\"\n\ntransaction(symbol: String, from: Address, to: Address, amount: UFix64) {\n  prepare(signer: auth(Storage) &Account) {\n    let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n      ?? panic(\"missing admin\")\n    admin.emitTransfer(symbol: symbol, from: from, to: to, amount: amount)\n  }\n}\n\n\n";
files["transactions/diagnostic/admin/emit-vault-created.cdc"] = "import \"Fractional\"\n\ntransaction(\n    vaultId: String,\n    collection: String,\n    tokenId: UInt64,\n    shareSymbol: String,\n    policy: String,\n    creator: Address\n) {\n    prepare(signer: auth(Storage) &Account) {\n        let admin: &Fractional.Admin = signer.storage.borrow<&Fractional.Admin>(from: /storage/FractionalAdmin)\n          ?? panic(\"missing admin\")\n        admin.emitVaultCreated(\n            vaultId: vaultId,\n            collection: collection,\n            tokenId: tokenId,\n            shareSymbol: shareSymbol,\n            policy: policy,\n            creator: creator\n        )\n    }\n}\n\n\n";
files["transactions/custody/user/PublishCustodyCap.cdc"] = "import \"Fractional\"\n\ntransaction {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability, Storage) &Account) {\n    if signer.storage.borrow<&Fractional.Custody>(from: /storage/FractionalCustody) == nil {\n      signer.storage.save(<- Fractional.createCustody(), to: /storage/FractionalCustody)\n    }\n    let existing: Capability<&{Fractional.CustodyPublic}> = signer.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n    if !existing.check() {\n      let _: Capability? = signer.capabilities.unpublish(Fractional.CustodyPublicPath)\n      signer.capabilities.publish(\n        signer.capabilities.storage.issue<&{Fractional.CustodyPublic}>(/storage/FractionalCustody),\n        at: Fractional.CustodyPublicPath\n      )\n    }\n  }\n}\n\n\n";
files["transactions/custody/user/deposit.cdc"] = "import \"NonFungibleToken\"\nimport \"Fractional\"\n\ntransaction(collectionStoragePath: String, tokenId: UInt64, vaultId: String) {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability, Storage) &Account) {\n    let storagePath: StoragePath = StoragePath(identifier: collectionStoragePath)!\n    let providerRef: auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider} = signer.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: storagePath)\n      ?? panic(\"missing provider with withdraw at storage path\")\n    let nft: @{NonFungibleToken.NFT} <- providerRef.withdraw(withdrawID: tokenId)\n\n    if signer.storage.borrow<&Fractional.Custody>(from: /storage/FractionalCustody) == nil {\n      signer.storage.save(<- Fractional.createCustody(), to: /storage/FractionalCustody)\n    }\n    let _ = signer.capabilities.unpublish(Fractional.CustodyPublicPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&{Fractional.CustodyPublic}>(/storage/FractionalCustody),\n      at: Fractional.CustodyPublicPath\n    )\n    let custody: &Fractional.Custody = signer.storage.borrow<&Fractional.Custody>(from: /storage/FractionalCustody)\n      ?? panic(\"custody not found\")\n    custody.deposit(vaultId: vaultId, nft: <-nft)\n    let _res = custody.borrowViewResolver(vaultId: vaultId) ?? panic(\"resolver not available after deposit\")\n  }\n}\n\n\n";
files["transactions/custody/user/setup-lockbox.cdc"] = "import \"Fractional\"\n\ntransaction {\n  prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability, Storage) &Account) {\n    if signer.storage.borrow<&Fractional.LockBox>(from: /storage/FractionalLockBox) == nil {\n      signer.storage.save(<- Fractional.createLockBox(), to: /storage/FractionalLockBox)\n    }\n    let _: Capability? = signer.capabilities.unpublish(Fractional.LockBoxPublicPath)\n    signer.capabilities.publish(\n      signer.capabilities.storage.issue<&{Fractional.LockBoxPublic}>(/storage/FractionalLockBox),\n      at: Fractional.LockBoxPublicPath\n    )\n  }\n}\n\n\n";
files["transactions/custody/user/setup.cdc"] = "import \"Fractional\"\n\ntransaction {\n  prepare(signer: auth(Storage) &Account) {\n    if signer.storage.borrow<&Fractional.Custody>(from: /storage/FractionalCustody) == nil {\n      signer.storage.save(<- Fractional.createCustody(), to: /storage/FractionalCustody)\n    }\n  }\n}\n\n";
files["transactions/custody/admin/publish-custody-cap.cdc"] = "import \"Fractional\"\n\ntransaction(account: Address) {\n  prepare(admin: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, UnpublishCapability, Storage) &Account) {\n    let targetAccount: &Account = getAccount(account)\n    \n    // Check if custody resource exists\n    let custodyRef: &Fractional.Custody? = targetAccount.storage.borrow<&Fractional.Custody>(from: /storage/FractionalCustody)\n    if custodyRef == nil {\n      panic(\"Custody resource not found for account\")\n    }\n    \n    // Check if capability is already published\n    let existing: Capability<&{Fractional.CustodyPublic}>? = targetAccount.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n    \n    if existing == nil || !existing!.check() {\n      // Unpublish existing capability if it exists\n      let _: Capability? = targetAccount.capabilities.unpublish(Fractional.CustodyPublicPath)\n      \n      // Publish new capability\n      targetAccount.capabilities.publish(\n        targetAccount.capabilities.storage.issue<&{Fractional.CustodyPublic}>(/storage/FractionalCustody),\n        at: Fractional.CustodyPublicPath\n      )\n    }\n  }\n}\n";
files["transactions/contracts/admin/add_contract_with_init.cdc"] = "transaction(name: String, codeHex: String, initName: String, initSymbol: String, initDecimals: UInt8, initMaxSupply: UFix64?) {\n  prepare(signer: auth(Contracts) &Account) {\n    signer.contracts.add(\n      name: name,\n      code: codeHex.decodeHex(),\n      initName,\n      initSymbol,\n      initDecimals,\n      initMaxSupply\n    )\n  }\n}\n\n\n";
files["transactions/buyout/buy-and-burn.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"Fractional\"\n\n/// Buy a holder's shares for FLOW and burn them immediately.\n/// This transaction handles a single holder at a time.\n/// Repeat until VaultShareToken totalSupply == 0, then run admin redeem-and-withdraw.\ntransaction(\n  vaultId: String,\n  shares: UFix64,\n  pricePerShare: UFix64,\n  minPayment: UFix64\n) {\n  prepare(\n    buyer: auth(Storage, BorrowValue, SaveValue) &Account,\n    holder: auth(Storage, BorrowValue) &Account\n  ) {\n    let _v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n\n    // 1) Ensure buyer share vault exists (to burn from)\n    let sharePath = VaultShareToken.getVaultStoragePath()\n    if buyer.storage.borrow<&VaultShareToken.Vault>(from: sharePath) == nil {\n      let empty: @{FungibleToken.Vault} <- VaultShareToken.createEmptyVault(vaultType: Type<@VaultShareToken.Vault>())\n      let casted: @VaultShareToken.Vault <- empty as! @VaultShareToken.Vault\n      buyer.storage.save(<-casted, to: sharePath)\n    }\n    let buyerShareRef = buyer.storage.borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: sharePath)\n      ?? panic(\"buyer share vault not found\")\n\n    // 2) Withdraw shares from holder and deposit to buyer (so we can burn via admin)\n    let holderShareRef = holder.storage\n      .borrow<auth(FungibleToken.Withdraw) &VaultShareToken.Vault>(from: sharePath)\n      ?? panic(\"holder share vault not found\")\n    let lot: @VaultShareToken.Vault <- holderShareRef.withdraw(amount: shares) as! @VaultShareToken.Vault\n    buyerShareRef.deposit(from: <-lot)\n\n    // 3) Pay holder in FLOW\n    let pay: UFix64 = pricePerShare * shares\n    let buyerFlowRef = buyer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"buyer FLOW vault not found\")\n    let out: @FlowToken.Vault <- buyerFlowRef.withdraw(amount: pay) as! @FlowToken.Vault\n    if out.balance < minPayment { panic(\"payment short\") }\n    let holderRecv = holder.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    if !holderRecv.check() { panic(\"holder FLOW receiver not linked\") }\n    holderRecv.borrow()!.deposit(from: <-out)\n\n    // 4) Burn the acquired shares from buyer vault\n    let admin = VaultShareToken.borrowAdmin() ?? panic(\"FT admin missing\")\n    admin.burn(from: buyerShareRef as auth(FungibleToken.Withdraw) &{FungibleToken.Vault}, amount: shares)\n  }\n}\n\n\n";
files["scripts/ExampleNFTGetIDs.cdc"] = "import \"ExampleNFT\"\n\naccess(all)\nfun main(account: Address): [UInt64] {\n  let acct: &Account = getAccount(account)\n  let cap: Capability<&ExampleNFT.Collection> = acct.capabilities.get<&ExampleNFT.Collection>(ExampleNFT.CollectionPublicPath)\n  let colRef: &ExampleNFT.Collection = cap.borrow() ?? panic(\"missing ExampleNFT collection\")\n  return colRef.getIDs()\n}\n\n\n\n\n";
files["scripts/GetCollectionIds.cdc"] = "import \"NonFungibleToken\"\n\n// Get NFT IDs for a collection given account and public path identifier\naccess(all) view fun main(account: Address, publicPathIdentifier: String): [UInt64] {\n  let path: PublicPath = PublicPath(identifier: publicPathIdentifier)!\n  let cap: Capability<&{NonFungibleToken.CollectionPublic}> = getAccount(account)\n    .capabilities.get<&{NonFungibleToken.CollectionPublic}>(path)\n  if !cap.check() { return [] }\n  let col: &{NonFungibleToken.CollectionPublic}? = cap.borrow()\n  if col == nil { return [] }\n  return col!.getIDs()\n}\n\n\n";
files["scripts/GetFeeParams.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(vaultId: String): {String: UInt64} {\n  return Fractional.getFeeParams(vaultId: vaultId)\n}\n\n\n";
files["scripts/GetNFTDisplay.cdc"] = "import \"NonFungibleToken\"\nimport \"MetadataViews\"\nimport \"ViewResolver\"\n\n// Return basic display metadata for a given NFT if it implements MetadataViews.Display\n// - account: owner address of the collection\n// - publicPathIdentifier: the identifier part of the public path (e.g., \"MomentCollection\")\n// - tokenId: the NFT id to inspect\n// Returns a dictionary with keys: name, description, thumbnail (if available)\naccess(all) fun main(\n  account: Address,\n  publicPathIdentifier: String,\n  tokenId: UInt64\n): {String: String}? {\n  let path: PublicPath = PublicPath(identifier: publicPathIdentifier)!\n  let cap: Capability<&{NonFungibleToken.CollectionPublic}> = getAccount(account)\n    .capabilities.get<&{NonFungibleToken.CollectionPublic}>(path)\n  if !cap.check() { return nil }\n  let col = cap.borrow()\n  if col == nil { return nil }\n\n  if let nftRef = col!.borrowNFT(tokenId) {\n    // Try resolving MetadataViews.Display via ViewResolver\n    let resolver: &{ViewResolver.Resolver} = nftRef\n    if let display: MetadataViews.Display = resolver.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display? {\n        var out: {String: String} = {}\n        out[\"name\"] = display.name\n        out[\"description\"] = display.description\n        let url: String = (display.thumbnail as? MetadataViews.HTTPFile)?.url ?? \"\"\n        if url.length > 0 { out[\"thumbnail\"] = url }\n        return out\n    }\n  }\n  return nil\n}\n\n\n";
files["scripts/GetPendingFeeParams.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(vaultId: String): {String: UInt64}? {\n  return Fractional.getPendingFeeParams(vaultId: vaultId)\n}\n\n\n";
files["scripts/GetPlatformTreasuryBalance.cdc"] = "import \"FlowToken\"\n\naccess(all) fun main(admin: Address): UFix64 {\n  let cap: Capability<&FlowToken.Vault> = getAccount(admin).capabilities.get<&FlowToken.Vault>(/public/PlatformTreasury_FLOW)\n  if let vault: &FlowToken.Vault = cap.borrow() {\n    return vault.balance\n  }\n  return 0.0\n}\n\n\n";
files["scripts/GetShareBalance.cdc"] = "import \"VaultShareToken\"\n\n// Returns the caller's balance for the current vault's share FT (VaultShareToken)\n// Assumes the account has published a balance capability at VaultShareToken.getBalancePublicPath()\naccess(all) view fun main(account: Address): UFix64 {\n    let cap: Capability<&VaultShareToken.Vault> = getAccount(account).capabilities.get<&VaultShareToken.Vault>(VaultShareToken.getBalancePublicPath())\n    let vaultRef: &VaultShareToken.Vault = cap.borrow() ?? panic(\"VaultShareToken balance capability missing\")\n    return vaultRef.balance\n}\n\n\n";
files["scripts/GetShareBalanceByPath.cdc"] = "import \"FungibleToken\"\n\naccess(all) view fun main(account: Address, balancePath: String): UFix64 {\n  let cap = getAccount(account)\n    .capabilities.get<&{FungibleToken.Balance}>(PublicPath(identifier: balancePath)!)\n  if !cap.check() { return 0.0 }\n  let ref = cap.borrow() ?? panic(\"balance capability missing\")\n  return ref.balance\n}\n\n\n";
files["scripts/GetVault.cdc"] = "import \"Fractional\"\n\naccess(all)\nfun main(vaultId: String): Fractional.Vault? {\n  return Fractional.getVault(vaultId: vaultId)\n}\n\n\n\n\n";
files["scripts/GetVaultFT.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(vaultId: String): {String: String}? {\n  return Fractional.getVaultFT(vaultId: vaultId)\n}\n\n\n";
files["scripts/GetVaultIdBySymbol.cdc"] = "import \"Fractional\"\n\naccess(all)\nfun main(symbol: String): String? {\n  return Fractional.getVaultIdBySymbol(symbol: symbol)\n}\n\n\n\n\n";
files["scripts/GetVaultMaxSupply.cdc"] = "import \"Fractional\"\n\naccess(all) view fun main(vaultId: String): UFix64? {\n  let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n  return v.maxSupply\n}\n\n\n";
files["scripts/GetVaultShareSymbol.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(vaultId: String): String {\n  let v: Fractional.Vault = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n  return v.shareSymbol\n}\n\n\n";
files["scripts/GetVaultTotalSupply.cdc"] = "import \"VaultShareToken\"\n\naccess(all) fun main(): UFix64 {\n  return VaultShareToken.getTotalSupply()\n}";
files["scripts/GetVaultTotalSupplyFromFT.cdc"] = "import \"Fractional\"\nimport \"FungibleToken\"\nimport \"FungibleTokenMetadataViews\"\n\naccess(all) view fun main(vaultId: String): UFix64 {\n  // Get the FT metadata for this vault\n  let ftMeta: {String: String} = Fractional.getVaultFT(vaultId: vaultId) ?? panic(\"vault FT metadata not found\")\n\n  let ftAddress: Address = Address.fromString(ftMeta[\"address\"]!) ?? panic(\"invalid FT address\")\n  let ftContractName: String = ftMeta[\"name\"]!\n\n  // Borrow the contract account to access the FT contract\n  let ftContract: &{FungibleToken} = getAccount(ftAddress)\n    .contracts.borrow<&{FungibleToken}>(name: ftContractName) ?? panic(\"FT contract not found\")\n\n  // Get total supply from the contract-level view\n  let totalSupplyView: FungibleTokenMetadataViews.TotalSupply? = ftContract.resolveContractView(\n    resourceType: nil,\n    viewType: Type<FungibleTokenMetadataViews.TotalSupply>()\n  ) as! FungibleTokenMetadataViews.TotalSupply?\n\n  return totalSupplyView?.totalSupply ?? panic(\"totalSupply view not found\")\n}\n";
files["scripts/GetVaultTreasuryBalance.cdc"] = "import \"FlowToken\"\n\naccess(all) fun main(admin: Address, vaultId: String): UFix64 {\n  let pathId: String = \"VaultTreasury_FLOW_\".concat(vaultId)\n  let pubPath: PublicPath = PublicPath(identifier: pathId)!\n  let cap: Capability<&FlowToken.Vault> = getAccount(admin).capabilities.get<&FlowToken.Vault>(pubPath)\n  if let vault: &FlowToken.Vault = cap.borrow() {\n    return vault.balance\n  }\n  return 0.0\n}\n\n\n";
files["scripts/GetVaultTreasuryShareBalance.cdc"] = "import \"Fractional\"\nimport \"FungibleToken\"\n\n/// Read vault treasury share balance from the admin account\n/// Path: VaultTreasury_<CONTRACT_NAME>_<vaultId>\n/// Uses the public path if a Vault capability is published, otherwise returns 0.0\naccess(all) fun main(admin: Address, vaultId: String): UFix64 {\n  // Get vault FT metadata to construct the treasury path\n  let ftMeta: {String: String}? = Fractional.getVaultFT(vaultId: vaultId)\n  if ftMeta == nil { return 0.0 }\n  \n  let ftContractName: String = ftMeta![\"name\"]!\n  \n  // Construct vault treasury public path: VaultTreasury_<CONTRACT_NAME>_<vaultId>\n  let vaultTreasuryIdent: String = \"VaultTreasury_\".concat(ftContractName).concat(\"_\").concat(vaultId)\n  let pubPath: PublicPath = PublicPath(identifier: vaultTreasuryIdent)!\n  \n  // Try to borrow Vault capability from the public path (Vault implements Balance)\n  let cap: Capability<&{FungibleToken.Vault}>? = \n    getAccount(admin).capabilities.get<&{FungibleToken.Vault}>(pubPath)\n  \n  if let cap = cap {\n    if let vaultRef: &{FungibleToken.Vault} = cap.borrow() {\n      return vaultRef.balance\n    }\n  }\n  \n  return 0.0\n}\n\n";
files["scripts/GetWalletBalances.cdc"] = "import \"FungibleToken\"\nimport \"ConstantProductAMM\"\n\n// Read wallet balances for FLOW, a vault's share token (by symbol), and LP for an optional poolId.\n// - account: Address to inspect\n// - vaultSymbol: Share token symbol used to derive the balance public path (\"balance_\" + symbol)\n// - poolId: Optional pool identifier to read LP held in storage at /storage/AMM_LP_<poolId>\n// Returns a string map with keys: \"flow\", \"share\", \"lp\"\naccess(all) view fun main(account: Address, vaultSymbol: String, poolId: String?): {String: String} {\n  let out: {String: String} = {}\n\n  // FLOW balance via standard public balance capability\n  var flowBal: UFix64 = 0.0\n  if let f = getAccount(account).capabilities.borrow<&{FungibleToken.Balance}>(/public/flowTokenBalance) {\n    flowBal = f.balance\n  }\n  out[\"flow\"] = flowBal.toString()\n\n  // Share balance via derived public balance path: \"balance_\" + symbol\n  var shareBal: UFix64 = 0.0\n  let sharePath: PublicPath = PublicPath(identifier: \"balance_\".concat(vaultSymbol))!\n  if let s = getAccount(account).capabilities.borrow<&{FungibleToken.Balance}>(sharePath) {\n    shareBal = s.balance\n  }\n  out[\"share\"] = shareBal.toString()\n\n  // LP balance is stored in user storage as ConstantProductAMM.LPVault at /storage/AMM_LP_<poolId>\n  var lpBal: UFix64 = 0.0\n  if let pid = poolId {\n    let lpPubPath: PublicPath = PublicPath(identifier: \"AMM_LP_\".concat(pid))!\n    let lpCap: Capability<&ConstantProductAMM.LPVault> = getAccount(account).capabilities.get<&ConstantProductAMM.LPVault>(lpPubPath)\n    if let l = lpCap.borrow() {\n      lpBal = l.getBalance()\n    }\n  }\n  out[\"lp\"] = lpBal.toString()\n\n  return out\n}\n\n\n";
files["scripts/ListNftCollections.cdc"] = "import \"NonFungibleToken\"\n\n// Enumerate public paths on an account and return those exposing\n// NonFungibleToken.CollectionPublic\naccess(all) fun main(account: Address): [{String: String}] {\n  let acc: &Account = getAccount(account)\n  var results: [{String: String}] = []\n  var entry: {String: String} = {}\n\n  acc.storage.forEachPublic(fun (path: PublicPath, _t: Type): Bool {\n    let cap: Capability<&{NonFungibleToken.CollectionPublic}> = acc.capabilities.get<&{NonFungibleToken.CollectionPublic}>(path)\n    if let col: &{NonFungibleToken.CollectionPublic} = cap.borrow() {\n      let typeId: String = col.getType().identifier\n      entry[\"publicPath\"] = path.toString()\n      entry[\"typeId\"] = typeId\n      results.append(entry)\n    }\n    return true\n  })\n  return results\n}\n\n\n";
files["scripts/ListNftStorageCollections.cdc"] = "import \"NonFungibleToken\"\n\naccess(all) fun main(account: Address): [{String: String}] {\n  let acc: &Account = getAccount(account)\n  var results: [{String: String}] = []\n\n  acc.storage.forEachStored(fun (path: StoragePath, t: Type): Bool {\n    if t.isSubtype(of: Type<@{NonFungibleToken.Provider}>()) {\n      var entry: {String: String} = {}\n      entry[\"storagePath\"] = path.toString()\n      entry[\"typeId\"] = t.identifier\n      results.append(entry)\n    }\n    return true\n  })\n  return results\n}\n";
files["scripts/QuoteFees.cdc"] = "import \"FeeRouter\"\n\naccess(all) view fun main(vaultId: String, amount: UFix64): {String: UFix64} {\n  return FeeRouter.computeFeeSplits(vaultId: vaultId, amount: amount)\n}\n\n\n";
files["scripts/ResolveStoragePathFromPublic.cdc"] = "import \"NonFungibleToken\"\n\n// Resolve storage path identifier for a public collection path by inspecting provider references\naccess(all) view fun main(account: Address, publicPathIdentifier: String): String? {\n  let path = PublicPath(identifier: publicPathIdentifier)!\n  let cap = getAccount(account)\n    .capabilities.get<&{NonFungibleToken.Provider}>(path)\n  if !cap.check() { return nil }\n  let borrowed = cap.borrow()\n  if borrowed == nil { return nil }\n  // There is no direct way to derive storage path from a public capability.\n  // Return a conventional guess that many collections follow.\n  // Callers may verify separately.\n  return publicPathIdentifier\n}\n\n\n";
files["scripts/VaultCustodyDisplay.cdc"] = "import \"MetadataViews\"\nimport \"ViewResolver\"\nimport \"Fractional\"\n\naccess(all) fun main(vaultId: String): {String: String}? {\n  let v = Fractional.getVault(vaultId: vaultId) ?? panic(\"unknown vault\")\n  let custodian: Address = v.custodian\n\n  let lbCap: Capability<&{Fractional.LockBoxPublic}> =\n    getAccount(custodian).capabilities.get<&{Fractional.LockBoxPublic}>(Fractional.LockBoxPublicPath)\n  if let lb: &{Fractional.LockBoxPublic} = lbCap.borrow() {\n    if let r: &{ViewResolver.Resolver} = lb.borrowViewResolver(vaultId: vaultId) {\n      if let d: MetadataViews.Display = MetadataViews.getDisplay(r) {\n        let url: String = (d.thumbnail as? MetadataViews.HTTPFile)?.url ?? \"\"\n        return {\"name\": d.name, \"description\": d.description, \"thumbnail\": url}\n      }\n    }\n  }\n  return nil\n}\n";
files["scripts/VaultCustodyStatus.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(vaultId: String): Bool {\n  if let v = Fractional.getVault(vaultId: vaultId) {\n    return Fractional.isCustodyAlive(vaultId: vaultId, custodian: v.custodian)\n  }\n  return false\n}\n\n\n";
files["scripts/pools/AmmQuoteWithFees.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\nimport \"Fractional\"\n\n/// Read-only AMM quote with platform fee and split breakdown.\n/// direction: \"share_to_flow\" | \"flow_to_share\"\naccess(all) view fun main(\n  owner: Address,\n  poolId: String,\n  direction: String,\n  amountIn: UFix64,\n  vaultId: String\n): {String: UFix64} {\n  let pubPath: PublicPath = ConstantProductAMM.getPoolPublicPath(poolId: poolId)\n  let cap: Capability<&ConstantProductAMM.Pool> = getAccount(owner).capabilities.get<&ConstantProductAMM.Pool>(pubPath)\n  let p: &ConstantProductAMM.Pool = cap.borrow() ?? panic(\"invalid pool capability\")\n\n  // Platform AMM fee params (bps) and splits (bps)\n  let feeParams: {String: UInt64} = Fractional.getAmmFeeParams(vaultId: p.vaultId)\n  let ammFeeBps: UInt64 = feeParams[\"ammFeeBps\"] ?? 0\n  let vaultSplitBps: UInt64 = feeParams[\"ammFeeSplitVaultBps\"] ?? 0\n\n  // Compute taker fee on input and effective amount for quoting\n  let feeAmount: UFix64 = (amountIn * UFix64(ammFeeBps)) / 10000.0\n  let effectiveIn: UFix64 = amountIn > feeAmount ? (amountIn - feeAmount) : 0.0\n\n  var out: UFix64 = 0.0\n  if direction == \"share_to_flow\" {\n    out = p.quoteOutShareToFlow(amountIn: effectiveIn)\n  } else if direction == \"flow_to_share\" {\n    out = p.quoteOutFlowToShare(amountIn: effectiveIn)\n  } else {\n    panic(\"invalid direction tag\")\n  }\n\n  // Split breakdown\n  let vaultShare: UFix64 = (feeAmount * UFix64(vaultSplitBps)) / 10000.0\n  let protocolShare: UFix64 = feeAmount > vaultShare ? (feeAmount - vaultShare) : 0.0\n\n  return {\n    \"in\": amountIn,\n    \"out\": out,\n    \"feeAmount\": feeAmount,\n    \"feeBps\": UFix64(ammFeeBps),\n    \"vaultShare\": vaultShare,\n    \"protocolShare\": protocolShare\n  }\n}\n\n\n";
files["scripts/pools/GetPoolsByVault.cdc"] = "import \"ConstantProductAMM\"\n\n/// Lists poolIds for AMM pools published under a specific account's public storage,\n/// optionally filtered by `vaultId` (pass empty string to return all).\naccess(all) fun main(account: Address, vaultId: String): [String] {\n  let acct: &Account = getAccount(account)\n  var ids: [String] = []\n  acct.storage.forEachPublic(fun (path: PublicPath, _t: Type): Bool {\n    let cap: Capability<&ConstantProductAMM.Pool> = acct.capabilities.get<&ConstantProductAMM.Pool>(path)\n    if let p: &ConstantProductAMM.Pool = cap.borrow() {\n      if vaultId == \"\" || p.vaultId == vaultId {\n        ids.append(p.poolId)\n      }\n    }\n    return true\n  })\n  return ids\n}\n\n\n";
files["scripts/pools/GetPoolsByVaultDetailed.cdc"] = "import \"ConstantProductAMM\"\n\naccess(all) struct PoolInfo {\n  access(all) let poolId: String\n  access(all) let vaultId: String\n  access(all) let symbol: String\n  access(all) let feeBps: UInt64\n  access(all) let reserveShare: UFix64\n  access(all) let reserveFlow: UFix64\n\n  init(poolId: String, vaultId: String, symbol: String, feeBps: UInt64, reserveShare: UFix64, reserveFlow: UFix64) {\n    self.poolId = poolId\n    self.vaultId = vaultId\n    self.symbol = symbol\n    self.feeBps = feeBps\n    self.reserveShare = reserveShare\n    self.reserveFlow = reserveFlow\n  }\n}\n\n/// Lists detailed info for AMM pools published under a specific account's public storage,\n/// optionally filtered by `vaultId` (pass empty string to return all).\naccess(all) fun main(account: Address, vaultId: String): [PoolInfo] {\n  let acct: &Account = getAccount(account)\n  var out: [PoolInfo] = []\n  acct.storage.forEachPublic(fun (path: PublicPath, _t: Type): Bool {\n    let cap: Capability<&ConstantProductAMM.Pool> = acct.capabilities.get<&ConstantProductAMM.Pool>(path)\n    if let p: &ConstantProductAMM.Pool = cap.borrow() {\n      if vaultId == \"\" || p.vaultId == vaultId {\n        let r = p.reserves()\n        let rs: UFix64 = r[\"share\"] ?? 0.0\n        let rf: UFix64 = r[\"flow\"] ?? 0.0\n        out.append(PoolInfo(\n          poolId: p.poolId,\n          vaultId: p.vaultId,\n          symbol: p.symbol,\n          feeBps: p.feeBps,\n          reserveShare: rs,\n          reserveFlow: rf\n        ))\n      }\n    }\n    return true\n  })\n  return out\n}\n\n\n";
files["scripts/pools/GetTeamLPShareEquivalent.cdc"] = "import \"FungibleToken\"\nimport \"ConstantProductAMM\"\n\n// Compute share reserve proportion attributable to team LP for a specific pool\n// Returns: shareReserve * (sumTeamLP / totalLP); 0.0 if no LP\naccess(all) view fun main(owner: Address, poolId: String, team: [Address]): UFix64 {\n  let publicPath: PublicPath = ConstantProductAMM.getPoolPublicPath(poolId: poolId)\n  let cap: Capability<&ConstantProductAMM.Pool> = getAccount(owner).capabilities.get<&ConstantProductAMM.Pool>(publicPath)\n  if !cap.check() { return 0.0 }\n  let pool: &ConstantProductAMM.Pool = cap.borrow() ?? panic(\"invalid pool cap\")\n\n  let reserves: {String: UFix64} = pool.reserves()\n  let shareReserve: UFix64 = reserves[\"share\"] ?? 0.0\n  let totalLP: UFix64 = pool.getTotalLP()\n  if totalLP == 0.0 || shareReserve == 0.0 { return 0.0 }\n\n  var teamLP: UFix64 = 0.0\n  let lpPubId: String = \"AMM_LP_\".concat(poolId)\n  let lpPub: PublicPath = PublicPath(identifier: lpPubId)!\n  var i: Int = 0\n  while i < team.length {\n    let acct: Address = team[i]\n    let capLP: Capability<&ConstantProductAMM.LPVault> = getAccount(acct).capabilities.get<&ConstantProductAMM.LPVault>(lpPub)\n    if let lp = capLP.borrow() {\n      teamLP = teamLP + lp.getBalance()\n    }\n    i = i + 1\n  }\n\n  if teamLP == 0.0 { return 0.0 }\n  return shareReserve * (teamLP / totalLP)\n}\n\n\n";
files["scripts/pools/QuoteOut.cdc"] = "import \"ConstantProductAMM\"\n\n/// Returns the quoted output amount given an input amount and direction.\n/// direction: \"SHARE_TO_FLOW\" or \"FLOW_TO_SHARE\"\n///\naccess(all) fun main(pool: Capability<&ConstantProductAMM.Pool>, direction: String, amountIn: UFix64): UFix64 {\n  let p: &ConstantProductAMM.Pool = pool.borrow() ?? panic(\"invalid pool capability\")\n  if direction == \"SHARE_TO_FLOW\" {\n    return p.quoteOutShareToFlow(amountIn: amountIn)\n  }\n  if direction == \"FLOW_TO_SHARE\" {\n    return p.quoteOutFlowToShare(amountIn: amountIn)\n  }\n  panic(\"invalid direction\")\n}\n\n\n";
files["scripts/pools/QuoteViaActions.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"VaultShareToken\"\nimport \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\n\n// Read-only quote via adapter; accept UInt8 for direction to match API calls (0=ShareToFlow, 1=FlowToShare)\naccess(all) fun main(pool: Capability<&ConstantProductAMM.Pool>, direction: UInt8, amountIn: UFix64): {String: UFix64} {\n  let p: &ConstantProductAMM.Pool = pool.borrow() ?? panic(\"invalid pool capability\")\n  if direction == UInt8(0) { // ShareToFlow\n    let out: UFix64 = p.quoteOutShareToFlow(amountIn: amountIn)\n    return { \"in\": amountIn, \"out\": out }\n  } else if direction == UInt8(1) { // FlowToShare\n    let out: UFix64 = p.quoteOutFlowToShare(amountIn: amountIn)\n    return { \"in\": amountIn, \"out\": out }\n  }\n  panic(\"invalid direction\")\n}\n\n\n";
files["scripts/pools/QuoteViaActionsByOwner.cdc"] = "import \"FungibleToken\"\nimport \"FlowToken\"\nimport \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\nimport \"Fractional\"\n\n// Read-only quote via adapter by owner + poolId; direction: 0=ShareToFlow, 1=FlowToShare\naccess(all) fun main(owner: Address, poolId: String, direction: UInt8, amountIn: UFix64): {String: UFix64} {\n  let pubPath: PublicPath = ConstantProductAMM.getPoolPublicPath(poolId: poolId)\n  let cap: Capability<&ConstantProductAMM.Pool> = getAccount(owner).capabilities.get<&ConstantProductAMM.Pool>(pubPath)\n  let p: &ConstantProductAMM.Pool = cap.borrow() ?? panic(\"invalid pool capability\")\n  // Adjust input by platform AMM fee to reflect on-chain swap math\n  let feeParams: {String: UInt64} = Fractional.getAmmFeeParams(vaultId: p.vaultId)\n  let ammFeeBps: UInt64 = feeParams[\"ammFeeBps\"]!\n  let platformFee: UFix64 = (amountIn * UFix64(ammFeeBps)) / 10000.0\n  let effectiveIn: UFix64 = amountIn - platformFee\n\n  if direction == 0 { // ShareToFlow\n    let out: UFix64 = p.quoteOutShareToFlow(amountIn: effectiveIn)\n    return {\"in\": amountIn, \"out\": out}\n  } else if direction == 1 { // FlowToShare\n    let out: UFix64 = p.quoteOutFlowToShare(amountIn: effectiveIn)\n    return {\"in\": amountIn, \"out\": out}\n  }\n  panic(\"invalid direction\")\n}\n\n\n";
files["scripts/pools/QuoteViaSwapperByOwner.cdc"] = "import \"ConstantProductAMM\"\nimport \"ConstantProductAMMSwapper\"\nimport \"DeFiActions\"\n\n/// Read-only quote via ConstantProductAMMSwapper (DeFiActions-compatible).\n/// direction: \"share_to_flow\" | \"flow_to_share\"\naccess(all) view fun main(\n  owner: Address,\n  poolId: String,\n  direction: String,\n  amountIn: UFix64,\n  trader: Address\n): {String: UFix64} {\n  let pubPath: PublicPath = ConstantProductAMM.getPoolPublicPath(poolId: poolId)\n  let cap: Capability<&ConstantProductAMM.Pool> = getAccount(owner).capabilities.get<&ConstantProductAMM.Pool>(pubPath)\n  let p: &ConstantProductAMM.Pool = cap.borrow() ?? panic(\"invalid pool capability\")\n\n  var dir: ConstantProductAMMSwapper.Direction = ConstantProductAMMSwapper.Direction.ShareToFlow\n  if direction == \"share_to_flow\" {\n    dir = ConstantProductAMMSwapper.Direction.ShareToFlow\n  } else if direction == \"flow_to_share\" {\n    dir = ConstantProductAMMSwapper.Direction.FlowToShare\n  } else {\n    panic(\"invalid direction tag\")\n  }\n\n  // Build swapper and quote output for provided input using the same path as the tx\n  var swapperOpt: {DeFiActions.Swapper}? = nil\n  if dir == ConstantProductAMMSwapper.Direction.ShareToFlow {\n    swapperOpt = ConstantProductAMMSwapper.makeShareToFlowSwapper(poolCap: cap, trader: trader, id: nil)\n  } else {\n    swapperOpt = ConstantProductAMMSwapper.makeFlowToShareSwapper(poolCap: cap, trader: trader, id: nil)\n  }\n  let swapper: {DeFiActions.Swapper} = swapperOpt!\n\n  let concrete: ConstantProductAMMSwapper.AMMSwapper = swapper as! ConstantProductAMMSwapper.AMMSwapper\n  let qGeneric: {DeFiActions.Quote} = concrete.quoteOut(forProvided: amountIn, reverse: false)\n  let q: ConstantProductAMMSwapper.AMMQuote = qGeneric as! ConstantProductAMMSwapper.AMMQuote\n\n  return {\"in\": q.inAmount, \"out\": q.outAmount}\n}\n\n\n";
files["scripts/debug/CheckCustody.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(account: Address): {String: String} {\n  let acct: &Account = getAccount(account)\n  \n  // Check if custody resource exists\n  let custodyRef: &Fractional.Custody? = acct.storage.borrow<&Fractional.Custody>(from: /storage/FractionalCustody)\n  \n  if custodyRef == nil {\n    return {\"status\": \"no_custody_resource\", \"message\": \"Custody resource not found\"}\n  }\n  \n  // Check if custody capability is published\n  let cap: Capability<&{Fractional.CustodyPublic}>? = acct.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  \n  if cap == nil {\n    return {\"status\": \"no_custody_capability\", \"message\": \"Custody capability not published\"}\n  }\n  \n  if !cap!.check() {\n    return {\"status\": \"invalid_capability\", \"message\": \"Custody capability is invalid\"}\n  }\n  \n  return {\"status\": \"custody_ready\", \"message\": \"Custody resource and capability are properly set up\"}\n}\n";
files["scripts/debug/CheckCustodyCap.cdc"] = "import \"Fractional\"\n\naccess(all) fun main(account: Address): Bool {\n  let acct: &Account = getAccount(account)\n  let cap: Capability<&{Fractional.CustodyPublic}> =\n    acct.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  return cap.borrow() != nil\n}";
files["scripts/debug/CheckCustodyContents.cdc"] = "import \"Fractional\"\nimport \"ViewResolver\"\n\naccess(all) fun main(account: Address): [String] {\n  let acct: &Account = getAccount(account)\n  let cap: Capability<&{Fractional.CustodyPublic}> = acct.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  \n  if let custody: &{Fractional.CustodyPublic} = cap.borrow() {\n    // We can't directly access the holdings, but we can try to borrow view resolvers\n    // for known vault IDs to see what's in custody\n    let testVaults = [\"VAULT001\", \"VAULT002\", \"VAULT003\"]\n    var foundVaults: [String] = []\n    \n    for vaultId in testVaults {\n      if let resolver: &{ViewResolver.Resolver} = custody.borrowViewResolver(vaultId: vaultId) {\n        foundVaults.append(vaultId)\n      }\n    }\n    \n    return foundVaults\n  }\n  \n  return []\n}\n";
files["scripts/debug/DebugShareCaps.cdc"] = "import FungibleToken from 0xee82856bf20e2aa6\nimport Fractional from 0xf8d6e0586b0a20c7\n\naccess(all) view fun main(vaultId: String, account: Address): {String: Bool} {\n  let meta = Fractional.getVaultFT(vaultId: vaultId) ?? panic(\"no per-vault FT metadata\")\n  let recvPath = PublicPath(identifier: meta[\"receiver\"]!)!\n  let balPath  = PublicPath(identifier: meta[\"balance\"]!)!\n\n  let recvCap = getAccount(account).capabilities.get<&{FungibleToken.Receiver}>(recvPath)\n  let balCap  = getAccount(account).capabilities.get<&{FungibleToken.Balance}>(balPath)\n\n  return {\n    \"hasReceiverCap\": recvCap.check(),\n    \"hasBalanceCap\": balCap.check()\n  }\n}";
files["scripts/debug/DebugVaultResolver.cdc"] = "import \"Fractional\"\nimport \"ViewResolver\"\nimport \"MetadataViews\"\n\naccess(all) fun main(account: Address, vaultId: String): {String: String} {\n  let acct = getAccount(account)\n  let cap = acct.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  if !cap.check() { return {\"status\":\"no_cap\"} }\n  if let c: &{Fractional.CustodyPublic} = cap.borrow() {\n    if let r: &{ViewResolver.Resolver} = c.borrowViewResolver(vaultId: vaultId) {\n      let hasDisplay = (r.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?) != nil\n      return {\"status\":\"ok\", \"display\": hasDisplay ? \"yes\" : \"no\"}\n    }\n    return {\"status\":\"no_resolver\"}\n  }\n  return {\"status\":\"no_custody\"}\n}";
files["scripts/debug/GetVault.cdc"] = "// flow/cadence/scripts/debug/GetVault.cdc\nimport \"Fractional\"\n\naccess(all) fun main(vaultId: String): {String: String}? {\n  if let v: Fractional.Vault = Fractional.getVault(vaultId: vaultId) {\n    return {\n      \"creator\": v.creator.toString(),\n      \"tokenId\": v.tokenId.toString(),\n      \"collectionPublicPath\": v.collectionPublicPath\n    }\n  }\n  return nil\n}";
files["scripts/debug/ReadVaultDisplay.cdc"] = "import \"MetadataViews\"\nimport \"ViewResolver\"\nimport \"Fractional\"\n\naccess(all) fun main(account: Address, vaultId: String): {String: String}? {\n  let acct: &Account = getAccount(account)\n  let cap: Capability<&{Fractional.CustodyPublic}> =\n    acct.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  if let c: &{Fractional.CustodyPublic} = cap.borrow() {\n    if let res: &{ViewResolver.Resolver} = c.borrowViewResolver(vaultId: vaultId) {\n      if let d: MetadataViews.Display = res.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display? {\n        let url: String = (d.thumbnail as? MetadataViews.HTTPFile)?.url ?? \"\"\n        return {\"name\": d.name, \"description\": d.description, \"thumbnail\": url}\n      }\n    }\n  }\n  return nil\n}\n\n\n";
files["scripts/debug/ShareBalanceByPath.cdc"] = "import FungibleToken from 0xee82856bf20e2aa6\nimport Fractional from 0xf8d6e0586b0a20c7\n\naccess(all) view fun main(vaultId: String, account: Address): UFix64 {\n  let meta = Fractional.getVaultFT(vaultId: vaultId) ?? panic(\"no per-vault FT metadata\")\n  let balPath = PublicPath(identifier: meta[\"balance\"]!)!\n\n  let cap = getAccount(account).capabilities.get<&{FungibleToken.Balance}>(balPath)\n  let ref = cap.borrow() ?? return 0.0;\n  return ref.balance\n}";
files["scripts/debug/TryBorrowResolver.cdc"] = "import \"Fractional\"\nimport \"ViewResolver\"\n\naccess(all) fun main(account: Address, vaultId: String): Bool {\n  let cap: Capability<&{Fractional.CustodyPublic}> = getAccount(account).capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  if let c: &{Fractional.CustodyPublic} = cap.borrow() {\n    return c.borrowViewResolver(vaultId: vaultId) != nil\n  }\n  return false\n}";
files["scripts/debug/VaultCustodyDisplay.cdc"] = "import \"MetadataViews\"\nimport \"ViewResolver\"\nimport \"Fractional\"\n\naccess(all) fun main(account: Address, vaultId: String, tokenId: UInt64): {String: String}? {\n  let acct: &Account = getAccount(account)\n  let cap: Capability<&{Fractional.CustodyPublic}> =\n    acct.capabilities.get<&{Fractional.CustodyPublic}>(Fractional.CustodyPublicPath)\n  if let c: &{Fractional.CustodyPublic} = cap.borrow() {\n    if let res: &{ViewResolver.Resolver} = c.borrowViewResolver(vaultId: vaultId) {\n      if let d: MetadataViews.Display = res.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display? {\n        let url: String = (d.thumbnail as? MetadataViews.HTTPFile)?.url ?? \"\"\n        return {\"name\": d.name, \"description\": d.description, \"thumbnail\": url}\n      }\n    }\n  }\n  return nil\n}\n";
export const list = Object.keys(files);
export function get(pathRel) { return files[pathRel] ?? null }
export const transactions_vault_user_submit_and_mint_dynamic = files["transactions/vault/user/submit-and-mint_dynamic.cdc"];
export const transactions_vault_user_submit_from_collection = files["transactions/vault/user/submit-from-collection.cdc"];
export const transactions_vault_admin_activate_fee_params = files["transactions/vault/admin/activate-fee-params.cdc"];
export const transactions_vault_admin_create_from_nft = files["transactions/vault/admin/create-from-nft.cdc"];
export const transactions_vault_admin_create = files["transactions/vault/admin/create.cdc"];
export const transactions_vault_admin_init_series_vault = files["transactions/vault/admin/init-series-vault.cdc"];
export const transactions_vault_admin_redeem_and_withdraw = files["transactions/vault/admin/redeem-and-withdraw.cdc"];
export const transactions_vault_admin_redeem = files["transactions/vault/admin/redeem.cdc"];
export const transactions_vault_admin_schedule_fee_params = files["transactions/vault/admin/schedule-fee-params.cdc"];
export const transactions_vault_admin_set_max_supply = files["transactions/vault/admin/set-max-supply.cdc"];
export const transactions_vault_admin_set_ft = files["transactions/vault/admin/set_ft.cdc"];
export const transactions_treasury_admin_ensure_caps = files["transactions/treasury/admin/ensure-caps.cdc"];
export const transactions_treasury_admin_ensure_treasuries_dynamic = files["transactions/treasury/admin/ensure_treasuries_dynamic.cdc"];
export const transactions_shares_user_setup = files["transactions/shares/user/setup.cdc"];
export const transactions_shares_user_setup_dynamic = files["transactions/shares/user/setup_dynamic.cdc"];
export const transactions_shares_admin_ensure_admin_caps_dynamic = files["transactions/shares/admin/ensure_admin_caps_dynamic.cdc"];
export const transactions_shares_admin_mint = files["transactions/shares/admin/mint.cdc"];
export const transactions_shares_admin_mint_dynamic = files["transactions/shares/admin/mint_dynamic.cdc"];
export const transactions_shares_admin_mint_to_treasury_dynamic = files["transactions/shares/admin/mint_to_treasury_dynamic.cdc"];
export const transactions_shares_admin_set_transfer_mode = files["transactions/shares/admin/set-transfer-mode.cdc"];
export const transactions_shares_admin_transfer = files["transactions/shares/admin/transfer.cdc"];
export const transactions_shares_admin_transfer_dynamic = files["transactions/shares/admin/transfer_dynamic.cdc"];
export const transactions_setup_user_setup_flow_vault = files["transactions/setup/user/setup-flow-vault.cdc"];
export const transactions_setup_admin_fund_flow = files["transactions/setup/admin/fund-flow.cdc"];
export const transactions_setup_admin_setup_admin = files["transactions/setup/admin/setup-admin.cdc"];
export const transactions_scheduler_admin_init = files["transactions/scheduler/admin/init.cdc"];
export const transactions_scheduler_admin_initV2 = files["transactions/scheduler/admin/initV2.cdc"];
export const transactions_scheduler_admin_schedule = files["transactions/scheduler/admin/schedule.cdc"];
export const transactions_scheduler_admin_scheduleV2 = files["transactions/scheduler/admin/scheduleV2.cdc"];
export const transactions_pools_user_AddLiquidity = files["transactions/pools/user/AddLiquidity.cdc"];
export const transactions_pools_user_AddLiquidityOptimal = files["transactions/pools/user/AddLiquidityOptimal.cdc"];
export const transactions_pools_user_AddLiquidityWithChange = files["transactions/pools/user/AddLiquidityWithChange.cdc"];
export const transactions_pools_user_CreatePool = files["transactions/pools/user/CreatePool.cdc"];
export const transactions_pools_user_RemoveLiquidity = files["transactions/pools/user/RemoveLiquidity.cdc"];
export const transactions_pools_user_SwapExactIn = files["transactions/pools/user/SwapExactIn.cdc"];
export const transactions_pools_user_SwapViaActions = files["transactions/pools/user/SwapViaActions.cdc"];
export const transactions_pools_user_ZapAddLiquidityViaActions = files["transactions/pools/user/ZapAddLiquidityViaActions.cdc"];
export const transactions_pools_admin_CreatePool = files["transactions/pools/admin/CreatePool.cdc"];
export const transactions_pools_admin_SeedLiquidity = files["transactions/pools/admin/SeedLiquidity.cdc"];
export const transactions_listings_user_cancel = files["transactions/listings/user/cancel.cdc"];
export const transactions_listings_user_create_safe = files["transactions/listings/user/create_safe.cdc"];
export const transactions_listings_user_expire = files["transactions/listings/user/expire.cdc"];
export const transactions_listings_user_fill = files["transactions/listings/user/fill.cdc"];
export const transactions_listings_user_has_share_setup = files["transactions/listings/user/has-share-setup.cdc"];
export const transactions_listings_user_pay = files["transactions/listings/user/pay.cdc"];
export const transactions_listings_user_setup_shares = files["transactions/listings/user/setup-shares.cdc"];
export const transactions_listings_user_swapFill = files["transactions/listings/user/swapFill.cdc"];
export const transactions_listings_admin_cancel = files["transactions/listings/admin/cancel.cdc"];
export const transactions_listings_admin_create = files["transactions/listings/admin/create.cdc"];
export const transactions_listings_admin_expire = files["transactions/listings/admin/expire.cdc"];
export const transactions_listings_admin_fill = files["transactions/listings/admin/fill.cdc"];
export const transactions_listings_admin_settle_fill = files["transactions/listings/admin/settle-fill.cdc"];
export const transactions_governance_admin_buyout_finalize = files["transactions/governance/admin/buyout-finalize.cdc"];
export const transactions_governance_admin_buyout_propose = files["transactions/governance/admin/buyout-propose.cdc"];
export const transactions_governance_admin_buyout_vote = files["transactions/governance/admin/buyout-vote.cdc"];
export const transactions_example_nft_user_setup_collection = files["transactions/example-nft/user/setup-collection.cdc"];
export const transactions_example_nft_admin_mint_to = files["transactions/example-nft/admin/mint-to.cdc"];
export const transactions_distributions_user_claim = files["transactions/distributions/user/claim.cdc"];
export const transactions_distributions_scheduler_execute = files["transactions/distributions/scheduler/execute.cdc"];
export const transactions_distributions_admin_init_handler = files["transactions/distributions/admin/init-handler.cdc"];
export const transactions_distributions_admin_schedule = files["transactions/distributions/admin/schedule.cdc"];
export const transactions_diagnostic_admin_emit_shares_minted = files["transactions/diagnostic/admin/emit-shares-minted.cdc"];
export const transactions_diagnostic_admin_emit_transfer = files["transactions/diagnostic/admin/emit-transfer.cdc"];
export const transactions_diagnostic_admin_emit_vault_created = files["transactions/diagnostic/admin/emit-vault-created.cdc"];
export const transactions_custody_user_PublishCustodyCap = files["transactions/custody/user/PublishCustodyCap.cdc"];
export const transactions_custody_user_deposit = files["transactions/custody/user/deposit.cdc"];
export const transactions_custody_user_setup_lockbox = files["transactions/custody/user/setup-lockbox.cdc"];
export const transactions_custody_user_setup = files["transactions/custody/user/setup.cdc"];
export const transactions_custody_admin_publish_custody_cap = files["transactions/custody/admin/publish-custody-cap.cdc"];
export const transactions_contracts_admin_add_contract_with_init = files["transactions/contracts/admin/add_contract_with_init.cdc"];
export const transactions_buyout_buy_and_burn = files["transactions/buyout/buy-and-burn.cdc"];
export const scripts_ExampleNFTGetIDs = files["scripts/ExampleNFTGetIDs.cdc"];
export const scripts_GetCollectionIds = files["scripts/GetCollectionIds.cdc"];
export const scripts_GetFeeParams = files["scripts/GetFeeParams.cdc"];
export const scripts_GetNFTDisplay = files["scripts/GetNFTDisplay.cdc"];
export const scripts_GetPendingFeeParams = files["scripts/GetPendingFeeParams.cdc"];
export const scripts_GetPlatformTreasuryBalance = files["scripts/GetPlatformTreasuryBalance.cdc"];
export const scripts_GetShareBalance = files["scripts/GetShareBalance.cdc"];
export const scripts_GetShareBalanceByPath = files["scripts/GetShareBalanceByPath.cdc"];
export const scripts_GetVault = files["scripts/GetVault.cdc"];
export const scripts_GetVaultFT = files["scripts/GetVaultFT.cdc"];
export const scripts_GetVaultIdBySymbol = files["scripts/GetVaultIdBySymbol.cdc"];
export const scripts_GetVaultMaxSupply = files["scripts/GetVaultMaxSupply.cdc"];
export const scripts_GetVaultShareSymbol = files["scripts/GetVaultShareSymbol.cdc"];
export const scripts_GetVaultTotalSupply = files["scripts/GetVaultTotalSupply.cdc"];
export const scripts_GetVaultTotalSupplyFromFT = files["scripts/GetVaultTotalSupplyFromFT.cdc"];
export const scripts_GetVaultTreasuryBalance = files["scripts/GetVaultTreasuryBalance.cdc"];
export const scripts_GetVaultTreasuryShareBalance = files["scripts/GetVaultTreasuryShareBalance.cdc"];
export const scripts_GetWalletBalances = files["scripts/GetWalletBalances.cdc"];
export const scripts_ListNftCollections = files["scripts/ListNftCollections.cdc"];
export const scripts_ListNftStorageCollections = files["scripts/ListNftStorageCollections.cdc"];
export const scripts_QuoteFees = files["scripts/QuoteFees.cdc"];
export const scripts_ResolveStoragePathFromPublic = files["scripts/ResolveStoragePathFromPublic.cdc"];
export const scripts_VaultCustodyDisplay = files["scripts/VaultCustodyDisplay.cdc"];
export const scripts_VaultCustodyStatus = files["scripts/VaultCustodyStatus.cdc"];
export const scripts_pools_AmmQuoteWithFees = files["scripts/pools/AmmQuoteWithFees.cdc"];
export const scripts_pools_GetPoolsByVault = files["scripts/pools/GetPoolsByVault.cdc"];
export const scripts_pools_GetPoolsByVaultDetailed = files["scripts/pools/GetPoolsByVaultDetailed.cdc"];
export const scripts_pools_GetTeamLPShareEquivalent = files["scripts/pools/GetTeamLPShareEquivalent.cdc"];
export const scripts_pools_QuoteOut = files["scripts/pools/QuoteOut.cdc"];
export const scripts_pools_QuoteViaActions = files["scripts/pools/QuoteViaActions.cdc"];
export const scripts_pools_QuoteViaActionsByOwner = files["scripts/pools/QuoteViaActionsByOwner.cdc"];
export const scripts_pools_QuoteViaSwapperByOwner = files["scripts/pools/QuoteViaSwapperByOwner.cdc"];
export const scripts_debug_CheckCustody = files["scripts/debug/CheckCustody.cdc"];
export const scripts_debug_CheckCustodyCap = files["scripts/debug/CheckCustodyCap.cdc"];
export const scripts_debug_CheckCustodyContents = files["scripts/debug/CheckCustodyContents.cdc"];
export const scripts_debug_DebugShareCaps = files["scripts/debug/DebugShareCaps.cdc"];
export const scripts_debug_DebugVaultResolver = files["scripts/debug/DebugVaultResolver.cdc"];
export const scripts_debug_GetVault = files["scripts/debug/GetVault.cdc"];
export const scripts_debug_ReadVaultDisplay = files["scripts/debug/ReadVaultDisplay.cdc"];
export const scripts_debug_ShareBalanceByPath = files["scripts/debug/ShareBalanceByPath.cdc"];
export const scripts_debug_TryBorrowResolver = files["scripts/debug/TryBorrowResolver.cdc"];
export const scripts_debug_VaultCustodyDisplay = files["scripts/debug/VaultCustodyDisplay.cdc"];
